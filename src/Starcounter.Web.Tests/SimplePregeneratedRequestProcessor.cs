// Generated code. This code matches, parses and invokes Http handlers. The code was generated by the Starcounter http/spdy handler engine.

using Starcounter;
using Starcounter.Internal;
using Starcounter.Internal.Uri;
using System.Text;
using System.Collections.Generic;
using System;
using Starcounter.Advanced;

namespace __simple_urimatcher__ {

   public class GeneratedRequestProcessor : TopLevelRequestProcessor {
#if DEBUG
      internal static string UriOutput;
      internal static string TemplateOutput;
#endif

      public static int Sub0VerificationOffset = 0;
      public static int Sub1VerificationOffset = 6;
      public static int Sub2VerificationOffset = 14;
      public static int Sub3VerificationOffset = 22;
      public static int Sub4VerificationOffset = 22;
      public static int Sub5VerificationOffset = 33;
      public static byte[] VerificationBytes = new byte[] {
/* GET / */ (byte)'G',(byte)'E',(byte)'T',(byte)' ',(byte)'/',(byte)' '
/* GET /@i */ ,(byte)'G',(byte)'E',(byte)'T',(byte)' ',(byte)'/',(byte)'@',(byte)'i',(byte)' '
/* GET /@i */ ,(byte)'G',(byte)'E',(byte)'T',(byte)' ',(byte)'/',(byte)'@',(byte)'i',(byte)' '
/* GET /@s/@i */ ,(byte)'G',(byte)'E',(byte)'T',(byte)' ',(byte)'/',(byte)'@',(byte)'s',(byte)'/',(byte)'@',(byte)'i',(byte)' '
/* GET /@s/@i */ ,(byte)'G',(byte)'E',(byte)'T',(byte)' ',(byte)'/',(byte)'@',(byte)'s',(byte)'/',(byte)'@',(byte)'i',(byte)' '};
      public static IntPtr PointerVerificationBytes;

      public static Sub0Processor Sub0 = new Sub0Processor();
      public static Sub1Processor Sub1 = new Sub1Processor();
      public static Sub2Processor Sub2 = new Sub2Processor();
      public static Sub3Processor Sub3 = new Sub3Processor();
      public static Sub4Processor Sub4 = new Sub4Processor();
      public static Sub5Processor Sub5 = new Sub5Processor();

      public GeneratedRequestProcessor() {
         Registrations["GET / "] = Sub0;
         Registrations["GET /@i "] = Sub2;
         Registrations["GET /@s/@i "] = Sub5;
         PointerVerificationBytes = BitsAndBytes.Alloc(VerificationBytes.Length); // TODO. Free when program exists
         BitsAndBytes.SlowMemCopy(PointerVerificationBytes, VerificationBytes, (uint)VerificationBytes.Length);
      }

      public override bool Process(IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
#if DEBUG
         UriOutput = "";
         TemplateOutput = "";
         try {
#endif
            unsafe {
               byte* pfrag = (byte*)fragment;
               byte* ptempl = (byte*)PointerVerificationBytes;
               int nextSize = size;
               ptempl = ((byte*)PointerVerificationBytes + Sub0VerificationOffset + 0);
#if DEBUG
               UriOutput += "'";
               TemplateOutput += "'";
#endif
#if DEBUG
               for (int i = 0; i < 4; i++) {
                  UriOutput += (char)pfrag[i];
                  TemplateOutput += (char)ptempl[i];
               }
#endif
               nextSize -= 4;
               if (nextSize < 0 || (*(UInt32*)pfrag) != (*(UInt32*)ptempl)) {
                  handler = null;
                  resource = null;
                  return false;
               }
               pfrag += 4;
               ptempl += 4;
#if DEBUG
               for (int i = 0; i < 1; i++) {
                  UriOutput += (char)pfrag[i];
                  TemplateOutput += (char)ptempl[i];
               }
#endif
               nextSize--;
               if (nextSize < 0 || (*pfrag) != (*ptempl)) {
                  handler = null;
                  resource = null;
                  return false;
               }
               pfrag++;
               ptempl++;
#if DEBUG
               UriOutput += "' ";
               TemplateOutput += "' ";
#endif
               switch (*pfrag) {
                  case (byte)' ':
                  case (byte)'\r':
                  case (byte)'\n':
                     pfrag++;
                     nextSize--;
#if DEBUG
                     TemplateOutput += "{ } ";
                     UriOutput += "{ } ";
#endif
                     if (Sub0.SubProcess((IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                        return true;
                     break;
                  default:
                     if (Sub1.SubProcess((IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                        return true;
                     if (Sub3.SubProcess((IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                        return true;
                     break;
               }
            }
            handler = null;
            resource = null;
            return false;
#if DEBUG
         }
         finally {
            Console.WriteLine("URI:      " + UriOutput);
            Console.WriteLine("TEMPLATE: " + TemplateOutput);
            Console.WriteLine("-");
         }
#endif
      }

      public class Sub0Processor : SingleRequestProcessor {

         public bool SubProcess(IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
         //AT END
         handler = this;
         if (!invoke)
             resource = null;
         else
             resource = Code.Invoke();
         return true;
      }
      }

      public class Sub1Processor : SingleRequestProcessor<Int32> {

         public bool SubProcess(IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
            int val;
            int valueSize;
#if DEBUG
            UriOutput += "'parse:int' ";
            TemplateOutput += "'parse:int' ";
#endif
            if (ParseUriInt(fragment, size, out val, out valueSize)) {
               unsafe {
                  byte* pfrag = (byte*)fragment;
                  byte* ptempl = (byte*)PointerVerificationBytes;
                  int nextSize = size;
                  nextSize -= valueSize;
                  if (nextSize < 0) {
                     handler = null;
                     resource = null;
                     return false;
                  }
                  pfrag += valueSize;
                  if (Sub2.SubProcess(val, (IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                     return true;
               }
            }
            handler = null;
            resource = null;
            return false;
         }
      }

      public class Sub2Processor : SingleRequestProcessor<Int32> {

         public bool SubProcess(int val1, IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
         //AT END
         handler = this;
         if (!invoke)
             resource = null;
         else
             resource = Code.Invoke(val1);
         return true;
      }
      }

      public class Sub3Processor : RequestProcessor {

         public bool SubProcess(IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
            string val;
            int valueSize;
#if DEBUG
            UriOutput += "'parse:string' ";
            TemplateOutput += "'parse:string' ";
#endif
            if (ParseUriString(fragment, size, out val, out valueSize)) {
               unsafe {
                  byte* pfrag = (byte*)fragment;
                  byte* ptempl = (byte*)PointerVerificationBytes;
                  int nextSize = size;
                  nextSize -= valueSize;
                  if (nextSize < 0) {
                     handler = null;
                     resource = null;
                     return false;
                  }
                  pfrag += valueSize;
                  ptempl = ((byte*)PointerVerificationBytes + Sub4VerificationOffset + 7);
#if DEBUG
                  UriOutput += "'";
                  TemplateOutput += "'";
#endif
#if DEBUG
                  for (int i = 0; i < 1; i++) {
                     UriOutput += (char)pfrag[i];
                     TemplateOutput += (char)ptempl[i];
                  }
#endif
                  nextSize--;
                  if (nextSize < 0 || (*pfrag) != (*ptempl)) {
                     handler = null;
                     resource = null;
                     return false;
                  }
                  pfrag++;
                  ptempl++;
#if DEBUG
                  UriOutput += "' ";
                  TemplateOutput += "' ";
#endif
                  if (Sub4.SubProcess(val, (IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                     return true;
               }
            }
            handler = null;
            resource = null;
            return false;
         }
      }

      public class Sub4Processor : SingleRequestProcessor<String, Int32> {

         public bool SubProcess(string val1, IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
            int val;
            int valueSize;
#if DEBUG
            UriOutput += "'parse:int' ";
            TemplateOutput += "'parse:int' ";
#endif
            if (ParseUriInt(fragment, size, out val, out valueSize)) {
               unsafe {
                  byte* pfrag = (byte*)fragment;
                  byte* ptempl = (byte*)PointerVerificationBytes;
                  int nextSize = size;
                  nextSize -= valueSize;
                  if (nextSize < 0) {
                     handler = null;
                     resource = null;
                     return false;
                  }
                  pfrag += valueSize;
                  if (Sub5.SubProcess(val1, val, (IntPtr)pfrag, nextSize, invoke, request, out handler, out resource))
                     return true;
               }
            }
            handler = null;
            resource = null;
            return false;
         }
      }

      public class Sub5Processor : SingleRequestProcessor<String, Int32> {

         public bool SubProcess(string val1, int val2, IntPtr fragment, int size, bool invoke, HttpRequest request, out SingleRequestProcessorBase handler, out object resource) {
         //AT END
         handler = this;
         if (!invoke)
             resource = null;
         else
             resource = Code.Invoke(val1, val2);
         return true;
      }
      }
   }
}


