// Generated code. This code matches incomming methods (verbs) and URIs with Http handlers.
// The code was generated by the Starcounter http/spdy handler engine.

#define PREDEFINED
#ifdef PREDEFINED
typedef unsigned char           byte;
typedef unsigned short          word;
typedef unsigned int            dword;
typedef signed char             int8_t;
typedef unsigned char           uint8_t;
typedef signed short int        int16_t;
typedef unsigned short int      uint16_t;
typedef signed int              int32_t;
typedef unsigned int            uint32_t;
typedef unsigned long long      uint64_t;
typedef long long               int64_t;
typedef int8_t                  int8;
typedef uint8_t                 uint8;
typedef int16_t                 int16;
typedef uint16_t                uint16;
typedef int32_t                 int32;
typedef uint32_t                uint32;
typedef int64_t                 int64;
typedef uint64_t                uint64;
typedef unsigned char           uchar_t;
//typedef uint32_t                size_t;
typedef uint32_t                addr_t;
typedef int32_t                 pid_t;
typedef uint32_t HANDLER;
#define NULL 0



struct ParamInfo {
    uint16_t offset;
    uint16_t len;
};

inline bool IsDigit(char c) {
    return (c >= '0') && (c <= '9');
}

inline bool IsWhiteSpace(char c) {
    switch (c) {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
        case '\v':
        case '\f':
            return true;
        default:
            return false;
    }
}

inline int32_t MeasureSignedInt(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    switch (puri[offset]) {
    case '-':
    case '+': {
            if (max_len < 2)
                return 0;
            if (IsDigit(puri[offset + 1]))
                n += 2;
            else
                return -1;
            break;
        }
    default: {
            if (IsDigit(puri[offset]))
                n++;
            else
                return -1;
            break;
        }
    }
    while((n < max_len) && IsDigit(puri[offset + n]))
        n++;
    return n;
}

inline int32_t MeasureSignedDecimal(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    switch (puri[offset]) {
    case '-':
    case '+':
    case '.': {
            if (max_len < 2)
                return 0;
            if (IsDigit(puri[offset + 1]))
                n += 2;
            else
                return -1;
            break;
        }
    default: {
            if (IsDigit(puri[offset]))
                n++;
            else
                return -1;
            break;
        }
    }
    while((n < max_len) && (IsDigit(puri[offset + n]) || (puri[offset + n] == '.')))
        n++;
    return n;
}

inline int32_t MeasureBoolean(char* puri, int offset, int32_t max_len) {
    if (puri[offset] == 't' || puri[offset] == 'T') {
        return 4;
    }
    else {
        if (max_len < 5)
            return 0;
        return 5;
    }
    return 0;
}

inline int32_t MeasureDateTime(char* puri, int offset, int32_t max_len) {
    return 0;
}

inline int32_t MeasureStringUntilWhitespace(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    while((n < max_len) && (!IsWhiteSpace(puri[offset + n])))
        n++;
    return n;
}

inline int32_t MeasureStringUntilSymbol(char* puri, int offset, int32_t max_len, char c) {
    int32_t n = 0;
    while((n < max_len) && (puri[offset + n] != c))
        n++;
    return n;
}

inline bool IsEndChar(char c) {
    switch (c) {
        case ' ':
        case '\r':
        case '\n':
            return true;
        default:
            return false;
    }
}
#endif

static const int Sub0VerificationOffset = 0;
static const int Sub1VerificationOffset = 8;
static const int Sub2VerificationOffset = 8;
static const char VerificationBytes[] = {
    /* GET /@i */ 'G','E','T',' ','/','@','i',' '
    /* GET /@s/@i */ ,'G','E','T',' ','/','@','s','/','@','i',' '};


class GeneratedRequestProcessor {

   public:
   static HANDLER Process( char* puri, int fragment, int size, ParamInfo** params ) {
      HANDLER handler = NULL;
      char* ptempl;
      ptempl = ((char*)VerificationBytes + Sub0VerificationOffset + 0);
      if (fragment >= size || (*(uint32*)(&puri[fragment])) !=  (*(uint32*)ptempl) ) {
         return NULL;
      }
      fragment += 4;
      ptempl += 4;
      if (fragment >= size || (puri[fragment]) != (*ptempl) ) {
         return NULL;
      }
      fragment ++;
      ptempl ++;
      switch (puri[fragment]) {
         case ' ':
         case '\r':
         case '\n':
            return (HANDLER){{GET / }}
            break;
         default:
            if ( handler = Sub0Processor::Process(puri, fragment, size, params ) ) {
               return handler;
            }
            if ( handler = Sub1Processor::Process(puri, fragment, size, params ) ) {
               return handler;
            }
            break;
      }
      return NULL;
   }

   class Sub0Processor {
      public:
      static HANDLER Process(char* puri, int fragment, int size, ParamInfo** params ) {
         HANDLER handler = NULL;
         char* ptempl;
         int len = MeasureSignedInt(puri, fragment, size);
         if (len != -1) {
            (*params)->offset = fragment;
            (*params)->len = len;
            (*params)++;
            fragment += len;
            if (fragment >= size || !IsEndChar(puri[fragment]) ) {
               (*params)--;
               return NULL;
            }
            return (HANDLER){{GET /@i }}
         }
         return NULL;
      }
   };

   class Sub1Processor {
      public:
      static HANDLER Process(char* puri, int fragment, int size, ParamInfo** params ) {
         HANDLER handler = NULL;
         char* ptempl;
         ptempl = ((char*)VerificationBytes + Sub2VerificationOffset + 7);
         int len = MeasureStringUntilSymbol(puri, fragment, size, *ptempl);
         if (len != -1) {
            (*params)->offset = fragment;
            (*params)->len = len;
            (*params)++;
            fragment += len;
            ptempl = ((char*)VerificationBytes + Sub2VerificationOffset + 7);
            if (fragment >= size || (puri[fragment]) != (*ptempl) ) {
               (*params)--;
               return NULL;
            }
            fragment ++;
            ptempl ++;
            if ( handler = Sub2Processor::Process(puri, fragment, size, params ) ) {
               return handler;
            }
            (*params)--;
            return NULL;
         }
         return NULL;
      }
   };

   class Sub2Processor {
      public:
      static HANDLER Process(char* puri, int fragment, int size, ParamInfo** params ) {
         HANDLER handler = NULL;
         char* ptempl;
         int len = MeasureSignedInt(puri, fragment, size);
         if (len != -1) {
            (*params)->offset = fragment;
            (*params)->len = len;
            (*params)++;
            fragment += len;
            if (fragment >= size || !IsEndChar(puri[fragment]) ) {
               (*params)--;
               return NULL;
            }
            return (HANDLER){{GET /@s/@i }}
         }
         return NULL;
      }
   };
};

extern "C" __declspec(dllexport) HANDLER MatchUriRoot( char* puri, int size, ParamInfo** params ) {
   return GeneratedRequestProcessor::Process(puri, 0, size, params);
}
