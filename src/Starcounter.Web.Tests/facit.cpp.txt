// Generated code. This code matches incomming methods (verbs) and URIs with Http handlers.
// The code was generated by the Starcounter http/spdy handler engine.

#define PREDEFINED
#ifdef PREDEFINED
typedef unsigned char           byte;
typedef unsigned short          word;
typedef unsigned int            dword;
typedef signed char             int8_t;
typedef unsigned char           uint8_t;
typedef signed short int        int16_t;
typedef unsigned short int      uint16_t;
typedef signed int              int32_t;
typedef unsigned int            uint32_t;
typedef unsigned long long      uint64_t;
typedef long long               int64_t;
typedef int8_t                  int8;
typedef uint8_t                 uint8;
typedef int16_t                 int16;
typedef uint16_t                uint16;
typedef int32_t                 int32;
typedef uint32_t                uint32;
typedef int64_t                 int64;
typedef uint64_t                uint64;
typedef unsigned char           uchar_t;
//typedef uint32_t                size_t;
typedef uint32_t                addr_t;
typedef int32_t                 pid_t;
typedef uint32_t HANDLER;
#define NULL 0



struct ParamInfo {
    uint16_t offset;
    uint16_t len;
};

inline bool IsDigit(char c) {
    return (c >= '0') && (c <= '9');
}

inline bool IsWhiteSpace(char c) {
    return (c == ' ') || (c == '\n') || (c == '\t');
}

inline int32_t MeasureSignedInt(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    switch (puri[offset]) {
    case '-':
    case '+': {
            if (max_len < 2)
                return 0;
            if (IsDigit(puri[offset + 1]))
                n += 2;
            else
                return -1;
            break;
        }
    default: {
            if (IsDigit(puri[offset]))
                n++;
            else
                return -1;
            break;
        }
    }
    while((n < max_len) && IsDigit(puri[offset + n]))
        n++;
    return n;
}

inline int32_t MeasureSignedDecimal(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    switch (puri[offset]) {
    case '-':
    case '+':
    case '.': {
            if (max_len < 2)
                return 0;
            if (IsDigit(puri[offset + 1]))
                n += 2;
            else
                return -1;
            break;
        }
    default: {
            if (IsDigit(puri[offset]))
                n++;
            else
                return -1;
            break;
        }
    }
    while((n < max_len) && (IsDigit(puri[offset + n]) || (puri[offset + n] == '.')))
        n++;
    return n;
}

inline int32_t MeasureBoolean(char* puri, int offset, int32_t max_len) {
    if (puri[offset] == 't' || puri[offset] == 'T') {
        return 4;
    }
    else {
        if (max_len < 5)
            return 0;
        return 5;
    }
    return 0;
}

inline int32_t MeasureDateTime(char* puri, int offset, int32_t max_len) {
    return 0;
}

inline int32_t MeasureStringUntilWhitespace(char* puri, int offset, int32_t max_len) {
    int32_t n = 0;
    while((n < max_len) && (!IsWhiteSpace(puri[offset + n])))
        n++;
    return n;
}

inline int32_t MeasureStringUntilSymbol(char* puri, int offset, int32_t max_len, char c) {
    int32_t n = 0;
    while((n < max_len) && (puri[offset + n] != c))
        n++;
    return n;
}

inline bool IsEndChar(char c) {
    return (' ') || ('\r') || ('\n');
}
#endif

static const int Sub0VerificationOffset = 0;
static const int Sub1VerificationOffset = 8;
static const int Sub2VerificationOffset = 8;
static const char VerificationBytes[] = {
    /* GET /@i */ 'G','E','T',' ','/','@','i',' '
    /* GET /@s/@i */ ,'G','E','T',' ','/','@','s','/','@','i',' '};

static const HANDLER RootHandlerId = 1;
static const HANDLER Sub0HandlerId = 2;
static const HANDLER Sub2HandlerId = 3;

class GeneratedRequestProcessor {

   public:
      static HANDLER Process( char* puri, int fragment, int size, ParamInfo** params ) {
      HANDLER handler = NULL;
      char* ptempl = (char*)VerificationBytes;
         ptempl = ((char*)VerificationBytes + Sub0VerificationOffset + 0);
         if (fragment >= size || (*(uint32*)(&puri[fragment])) !=  (*(uint32*)ptempl) ) {
             return NULL;
         }
         fragment += 4;
         ptempl += 4;
         if (fragment >= size || (puri[fragment]) != (*ptempl) ) {
             return NULL;
         }
         fragment ++;
         ptempl ++;
         switch (puri[fragment]) {
            case ' ':
            case '\r':
            case '\n':
               return RootHandlerId;
               break;
            default:
               if ( handler = Sub0Processor::SubProcess(puri, fragment, size, params ) ) {
                  return handler;

               }
               if ( handler = Sub1Processor::SubProcess(puri, fragment, size, params ) ) {
                  return handler;

               }
               break;
         }
      return NULL;
   }

   class Sub0Processor {
      public:

      static HANDLER SubProcess(char* puri, int fragment, int size, ParamInfo** params ) {
         int len = MeasureSignedInt(puri, fragment, size );
         if (len != -1) {
             (*params)->offset = fragment;
             (*params)->len = len;
             fragment += len;
             if (fragment >= size || !IsEndChar(puri[fragment]) ) {
                 return NULL;
             }
             return Sub0HandlerId; // Found "GET /@i"
         }
         return NULL;
      }
   };

   class Sub1Processor {
      public:

        static HANDLER SubProcess(char* puri, int fragment, int size, ParamInfo** params ) {
            HANDLER handler = NULL;

            char* ptempl = (char*)VerificationBytes;
            ptempl = ((char*)VerificationBytes + Sub2VerificationOffset + 7);

            // TODO: Determine the end symbol for string.
            int len = MeasureStringUntilSymbol( puri, fragment, size, *ptempl );
            if (len != -1) {
                (*params)->offset = fragment;
                (*params)->len = len;
                fragment += len;
                if (fragment >= size || (puri[fragment]) != (*ptempl) ) {
                    return NULL;
                }
                fragment ++;
                (*params)++;
                handler = Sub2Processor::SubProcess( puri, fragment, size, params );
                if (handler == NULL) {
                    (*params)--;
                }
            }
            return handler;
        }
    };

    class Sub2Processor {
       public:
        static HANDLER SubProcess(char* puri, int fragment, int size, ParamInfo** params ) {
            int len = MeasureSignedInt( puri, fragment, size);
            if (len != -1) {
                (*params)->offset = fragment;
                (*params)->len = len;
                return Sub2HandlerId; // "GET /@s/@i
            }
            return NULL;
        }
    };
};

extern "C" __declspec(dllexport) HANDLER MatchUriRoot( char* puri, int size, ParamInfo** params ) {
    return GeneratedRequestProcessor::Process(puri, 0, size, params);
}

void main()
{
    ParamInfo test[16];
    ParamInfo* ptest = test;
    ParamInfo** pptest = &ptest;
    HANDLER hid = GeneratedRequestProcessor::Process("GET /a/1 ", 9, pptest);
}
