using System;
using System.Dynamic;using System.Linq.Expressions;using System.Reflection;using System.Linq;#if CLIENTusing Starcounter.Client.Template;namespace Starcounter.Client {#elseusing Starcounter.Templates;using System.Diagnostics;namespace Starcounter {#endif    public partial class Obj : IDynamicMetaObjectProvider {        DynamicMetaObject IDynamicMetaObjectProvider.GetMetaObject(            Expression parameter) {            return new DynamicPropertyMetaObject(parameter, this);        }        private class DynamicPropertyMetaObject : DynamicMetaObject {            internal DynamicPropertyMetaObject(                System.Linq.Expressions.Expression parameter,                Obj value)                : base(parameter, BindingRestrictions.Empty, value) {            }            public override DynamicMetaObject BindGetMember(GetMemberBinder binder) {
                // Special handling of properties declared in the baseclass (Obj) and overriden
                // using 'new', like a generic override of Data returning the correct type.
                if (binder.Name == "Data") {
                    return base.BindGetMember(binder);
                }                PropertyInfo pi = this.RuntimeType.GetProperty(binder.Name);                if (pi != null)                    return base.BindGetMember(binder);                var app = (Obj)Value;                TValue templ = (TValue)(app.Template.Properties[binder.Name]);//                Column c = Column.LookupColumn(binder.Name);                Debug.WriteLine("DynamicEntity Binding Get " + binder.Name);                MethodInfo method;                if (templ is TObjArr) {                    // The GetMethod does not deal with generic signatures causing an exception                    // for the ambiguous methods GetValue<T>( TObjArr x ) and GetValue( TObjArr x).                    // We need to call GetMethods instead (probably slower).                    // See http://stackoverflow.com/questions/11566613/how-do-i-distinguish-between-generic-and-non-generic-signatures-using-getmethod                    var mis = LimitType.GetMethods().Where( m => {                        if (m.Name.Equals("Get")) {
                            var paris = m.GetParameters();                            if (paris.Length == 1) {                                var pari = paris[0];//                                var found = (pari.ParameterType.Name.Equals("TArr`2")) && !m.IsGenericMethod;                            // Do we need to check instance of
                                var found = (pari.ParameterType.Name.Equals("TObjArr")) && !m.IsGenericMethod;                                return found;                            }                        }                        return false;                    });                    method = mis.First();                }                else {                    method = LimitType.GetMethod("Get", new Type[] { templ.GetType() });                }                /* (DynamicDurableProxy)this.Get(); */                Expression call = Expression.Call(Expression.Convert(this.Expression, this.LimitType), method, Expression.Constant(templ) );                // Expression wrapped = Expression.Block(call); // , Expression.New(typeof(object)));                Expression wrapped = Expression.Convert( call, binder.ReturnType );                return new DynamicMetaObject(wrapped, BindingRestrictions.GetTypeRestriction(Expression, LimitType));            }            public override DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value) {
                // Special handling of properties declared in the baseclass (Obj) and overriden
                // using 'new', like a generic override of Data returning the correct type.
                if (binder.Name == "Data") {
                    return base.BindSetMember(binder, value);
                }                PropertyInfo pi = this.RuntimeType.GetProperty(binder.Name);                if (pi != null)                    return base.BindSetMember(binder, value);                var app = (Obj)Value;                TValue templ = (TValue)(app.Template.Properties[binder.Name]);                MethodInfo method = LimitType.GetMethod("Set", new Type[] { templ.GetType(), value.LimitType });                if (method == null)                    throw new Exception(String.Format("No Set(uint,uint,{0}) method found when binding.", value.LimitType.Name));                //            Expression call = Expression.Call( Expression.Convert(this.Expression, this.LimitType), method, Expression.Constant(columnId), Expression.Constant(columnIndex), Expression.Convert(value.Expression, value.LimitType) );                Expression call = Expression.Call(Expression.Convert(this.Expression, this.LimitType), method, Expression.Constant(templ), Expression.Convert(value.Expression, templ.InstanceType));                Expression wrapped = Expression.Block(call, Expression.Convert(value.Expression, typeof(object)));                return new DynamicMetaObject(wrapped, BindingRestrictions.GetTypeRestriction(Expression, LimitType));            }        }    }}