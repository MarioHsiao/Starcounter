
Runtime: 0
Type: pos
Query: 
select e from Employee e where e.Manager = ?

Tokens: 
[<SELECT>][e][<FROM>][Employee][e][<WHERE>][e][.][Manager][=][?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,Manager)])
        variable(any,0)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Employee)])
            name(noName)
        )
    ]
    extent(0,Employee)
    comparison(
        any
        equal
        path(any,[extent(0,Employee),property(any,Manager)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Employee)])
            name(noName)
        )
    ]
    extent(0,Employee)
    comparison(
        any
        equal
        path(any,[extent(0,Employee),property(any,Manager)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        variable(object(Example.Employee),0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        variable(object(Example.Employee),0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from Example.Person p where p is Employee

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(is,path(any,[property(any,p)]),literal(type,Employee))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from Example.Person p where p is ?

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(is,path(any,[property(any,p)]),variable(any,0))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),variable(any,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),variable(any,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),variable(type,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),variable(type,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from Example.Person p where p is not ?

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][<NOT>][?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(isNot,path(any,[property(any,p)]),variable(any,0))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(any,[extent(0,Example.Person)]),variable(any,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(any,[extent(0,Example.Person)]),variable(any,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(object(Example.Person),[extent(0,Example.Person)]),variable(type,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(object(Example.Person),[extent(0,Example.Person)]),variable(type,0))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from Example.Person p where p is Employee

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(is,path(any,[property(any,p)]),literal(type,Employee))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from Example.Person p where p is not Employee

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][<NOT>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(isNot,path(any,[property(any,p)]),literal(type,Employee))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(any,[extent(0,Example.Person)]),literal(type,Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(isNot,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,Example.Employee))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select p from Example.Person p where ? is Employee

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][?][0][<IS>][Employee]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
1

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: neg
Query: 
select p from Example.Person p where p is String

Tokens: 
[<SELECT>][p][<FROM>][Example][.][Person][p][<WHERE>][p][<IS>][String]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,Example.Person)
        alias(any,p)
    )
    isTypePredicate(is,path(any,[property(any,p)]),literal(type,String))
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,String))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(any,[extent(0,Example.Person)]),literal(type,String))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,String))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    isTypePredicate(is,path(object(Example.Person),[extent(0,Example.Person)]),literal(type,String))
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Unknown class String.
]


Runtime: 0
Type: pos
Query: 
select * from location fetch 10 offsetkey binary 'fff'

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][10][<OFFSETKEY>][<BINARY>]['fff']

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(binary,'fff'))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(binary,'fff'))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch ? offsetkey ?

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][?][0][<OFFSETKEY>][?][1]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
2

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch 10 offset 20

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][10][<OFFSET>][20]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch ? offset ?

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][?][0][<OFFSET>][?][1]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
2

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.lastname from example.employee e where e.firstname = ? and e.commission = ? and e.hiredate = ? and e.salaryint16 = ? and e.manager = ?

Tokens: 
[<SELECT>][e][.][lastname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][=][?]
[0][<AND>][e][.][commission][=][?][1][<AND>][e][.][hiredate][=][?][2]
[<AND>][e][.][salaryint16][=][?][3][<AND>][e][.][manager][=][?][4]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,lastname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[property(any,e),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[property(any,e),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[property(any,e),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        operation(
            logical
            and
            comparison(
                boolean
                equal
                path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
                variable(boolean,1)
            )
            operation(
                logical
                and
                comparison(
                    datetime
                    equal
                    path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                    variable(datetime,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        numerical
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        variable(numerical,3)
                    )
                    comparison(
                        object(Example.Employee)
                        equal
                        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                        variable(object(Example.Employee),4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        operation(
            logical
            and
            comparison(
                boolean
                equal
                path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
                variable(boolean,1)
            )
            operation(
                logical
                and
                comparison(
                    datetime
                    equal
                    path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                    variable(datetime,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        numerical
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        variable(numerical,3)
                    )
                    comparison(
                        object(Example.Employee)
                        equal
                        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                        variable(object(Example.Employee),4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Number of variables: 
5

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select ((3 - 2) - 8) from Employee

Tokens: 
[<SELECT>][(][(][3][-][2][)][-][8][)][<FROM>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select (3 * ((6 - 8) / (4 - 8)) * 0) from Employee

Tokens: 
[<SELECT>][(][3][*][(][(][6][-][8][)][/][(][4][-][8]
[)][)][*][0][)][<FROM>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    multiplication
                    literal(integer,3)
                    operation(
                        numerical
                        division
                        operation(
                            numerical
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            numerical
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    multiplication
                    literal(integer,3)
                    operation(
                        numerical
                        division
                        operation(
                            numerical
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            numerical
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    multiplication
                    literal(integer,3)
                    operation(
                        numerical
                        division
                        operation(
                            numerical
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            numerical
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                decimal
                multiplication
                operation(
                    decimal
                    multiplication
                    literal(integer,3)
                    operation(
                        decimal
                        division
                        operation(
                            integer
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            integer
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                decimal
                multiplication
                operation(
                    decimal
                    multiplication
                    literal(integer,3)
                    operation(
                        decimal
                        division
                        operation(
                            integer
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            integer
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                decimal
                multiplication
                operation(
                    decimal
                    multiplication
                    literal(integer,3)
                    operation(
                        decimal
                        division
                        operation(
                            integer
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            integer
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                decimal
                multiplication
                operation(
                    decimal
                    multiplication
                    literal(integer,3)
                    operation(
                        decimal
                        division
                        operation(
                            integer
                            subtraction
                            literal(integer,6)
                            literal(integer,8)
                        )
                        operation(
                            integer
                            subtraction
                            literal(integer,4)
                            literal(integer,8)
                        )
                    )
                )
                literal(integer,0)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select (3 * 6 - 8 / 4 - 8 * 0) from Employee

Tokens: 
[<SELECT>][(][3][*][6][-][8][/][4][-][8][*][0][)][<FROM>]
[Employee]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    operation(
                        numerical
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        numerical
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    numerical
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    operation(
                        numerical
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        numerical
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    numerical
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    operation(
                        numerical
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        numerical
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    numerical
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                decimal
                subtraction
                operation(
                    decimal
                    subtraction
                    operation(
                        integer
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        decimal
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    integer
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                decimal
                subtraction
                operation(
                    decimal
                    subtraction
                    operation(
                        integer
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        decimal
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    integer
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                decimal
                subtraction
                operation(
                    decimal
                    subtraction
                    operation(
                        integer
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        decimal
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    integer
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                decimal
                subtraction
                operation(
                    decimal
                    subtraction
                    operation(
                        integer
                        multiplication
                        literal(integer,3)
                        literal(integer,6)
                    )
                    operation(
                        decimal
                        division
                        literal(integer,8)
                        literal(integer,4)
                    )
                )
                operation(
                    integer
                    multiplication
                    literal(integer,8)
                    literal(integer,0)
                )
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select (3 - 2 - 8) from Employee

Tokens: 
[<SELECT>][(][3][-][2][-][8][)][<FROM>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                operation(
                    integer
                    subtraction
                    literal(integer,3)
                    literal(integer,2)
                )
                literal(integer,8)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select (3 - (2 - 8)) from Employee

Tokens: 
[<SELECT>][(][3][-][(][2][-][8][)][)][<FROM>][Employee]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                subtraction
                literal(integer,3)
                operation(
                    numerical
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
            name(noName)
        )
    ]
    as(
        extent(any,Employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                literal(integer,3)
                operation(
                    numerical
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                subtraction
                literal(integer,3)
                operation(
                    numerical
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
            name(noName)
        )
    ]
    extent(0,Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                literal(integer,3)
                operation(
                    integer
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                integer
                subtraction
                literal(integer,3)
                operation(
                    integer
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                literal(integer,3)
                operation(
                    integer
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                subtraction
                literal(integer,3)
                operation(
                    integer
                    subtraction
                    literal(integer,2)
                    literal(integer,8)
                )
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch 10 offsetkey binary 'fff'

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][10][<OFFSETKEY>][<BINARY>]['fff']

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),key(literal(binary,'fff')))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(binary,'fff'))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(binary,'fff'))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch ? offsetkey ?

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][?][0][<OFFSETKEY>][?][1]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(binary,1))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
2

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch 10 offset 20

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][10][<OFFSET>][20]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(integer,10),literal(integer,20))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location fetch ? offset ?

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][?][0][<OFFSET>][?][1]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(variable(numerical,0),variable(numerical,1))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
2

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select * from location fetch '10' offset 'fff'

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>]['10'][<OFFSET>]['fff']

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(string,'10'),literal(string,'fff'))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(string,'10'),literal(string,'fff'))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(string,'10'),literal(string,'fff'))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(string,'10'),literal(string,'fff'))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(string,'10'),literal(string,'fff'))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    The number of rows to fetch must be of type integer.
    The fetch offset must be of type integer.
]


Runtime: 0
Type: neg
Query: 
select * from location fetch 10.1 offsetkey 'fff'

Tokens: 
[<SELECT>][*][<FROM>][location][<FETCH>][10][.][1][<OFFSETKEY>]['fff']

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(literal(decimal,10.1),key(literal(string,'fff')))
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(decimal,10.1),key(literal(string,'fff')))
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(literal(decimal,10.1),key(literal(string,'fff')))
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(decimal,10.1),literal(string,'fff'))
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(literal(decimal,10.1),literal(string,'fff'))
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    The number of rows to fetch must be of type integer.
    The fetch offset key must be of type binary.
]


Runtime: 0
Type: neg
Query: 
select cast(p.father as string) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][father][<AS>][string][)][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),cast(property(any,father),string)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),string)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),string)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select nonexistingmethod<myperson>() from example.person

Tokens: 
[<SELECT>][nonexistingmethod][<][myperson][>][(][)][<FROM>][example][.][person]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[gmethod(any,nonexistingmethod,[myperson],[])])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),gmethod(any,nonexistingmethod,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),gmethod(any,nonexistingmethod,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),gmethod(unknown,nonexistingmethod,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),gmethod(unknown,nonexistingmethod,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),gmethod(unknown,nonexistingmethod,[Example.MyPerson],[])])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),gmethod(unknown,nonexistingmethod,[Example.MyPerson],[])])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select firstname from employee where nonexistingmethod(manager) = true

Tokens: 
[<SELECT>][firstname][<FROM>][employee][<WHERE>][nonexistingmethod][(][manager][)][=][<TRUE>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,employee)
        alias(any,noName)
    )
    comparison(
        any
        equal
        path(any,[method(any,nonexistingmethod,[path(any,[property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee)]),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    comparison(
        any
        equal
        path(any,[extent(unspec,[extent(0,employee)]),method(any,nonexistingmethod,[path(any,[extent(unspec,[extent(0,employee)]),property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee)]),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    comparison(
        any
        equal
        path(any,[extent(unspec,[extent(0,employee)]),method(any,nonexistingmethod,[path(any,[extent(unspec,[extent(0,employee)]),property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        unknown
        equal
        path(unknown,[extent(0,Example.Employee),method(unknown,nonexistingmethod,[path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        unknown
        equal
        path(unknown,[extent(0,Example.Employee),method(unknown,nonexistingmethod,[path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.lastname from example.employee e where e.firstname = ? and e.commission = ? and e.hiredate = ? and e.salaryint16 = ? and e.manager = ?

Tokens: 
[<SELECT>][e][.][lastname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][=][?]
[0][<AND>][e][.][commission][=][?][1][<AND>][e][.][hiredate][=][?][2]
[<AND>][e][.][salaryint16][=][?][3][<AND>][e][.][manager][=][?][4]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,lastname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[property(any,e),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[property(any,e),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[property(any,e),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,commission)])
                variable(any,1)
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,hiredate)])
                    variable(any,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        variable(any,3)
                    )
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,manager)])
                        variable(any,4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        operation(
            logical
            and
            comparison(
                boolean
                equal
                path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
                variable(boolean,1)
            )
            operation(
                logical
                and
                comparison(
                    datetime
                    equal
                    path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                    variable(datetime,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        numerical
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        variable(numerical,3)
                    )
                    comparison(
                        object(Example.Employee)
                        equal
                        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                        variable(object(Example.Employee),4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        operation(
            logical
            and
            comparison(
                boolean
                equal
                path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
                variable(boolean,1)
            )
            operation(
                logical
                and
                comparison(
                    datetime
                    equal
                    path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                    variable(datetime,2)
                )
                operation(
                    logical
                    and
                    comparison(
                        numerical
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        variable(numerical,3)
                    )
                    comparison(
                        object(Example.Employee)
                        equal
                        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                        variable(object(Example.Employee),4)
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Number of variables: 
5

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.commission from example.employee e where e.firstname starts with ?

Tokens: 
[<SELECT>][e][.][commission][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<STARTS>][<WITH>]
[?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,commission)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[property(any,e),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,commission)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,commission)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                variable(string,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                variable(string,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where ? is null

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][?][0][<IS>][<NULL>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        is
        variable(any,0)
        literal(any,null)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        variable(any,0)
        literal(any,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        variable(any,0)
        literal(any,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        is
        variable(string,0)
        literal(string,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        is
        variable(string,0)
        literal(string,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select d.name deptname, d.idbinary id from example.department d where d.idbinary = ?

Tokens: 
[<SELECT>][d][.][name][deptname][,][d][.][idbinary][id][<FROM>][example][.][department][d]
[<WHERE>][d][.][idbinary][=][?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,d),property(any,name)])
            name(deptname)
        )
        as(
            path(any,[property(any,d),property(any,idbinary)])
            name(id)
        )
    ]
    as(
        extent(any,example.department)
        alias(any,d)
    )
    comparison(
        any
        equal
        path(any,[property(any,d),property(any,idbinary)])
        variable(any,0)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(deptname)
        )
        as(
            path(any,[extent(0,example.department),property(any,idbinary)])
            name(id)
        )
    ]
    extent(0,example.department)
    comparison(
        any
        equal
        path(any,[extent(0,example.department),property(any,idbinary)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(deptname)
        )
        as(
            path(any,[extent(0,example.department),property(any,idbinary)])
            name(id)
        )
    ]
    extent(0,example.department)
    comparison(
        any
        equal
        path(any,[extent(0,example.department),property(any,idbinary)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(deptname)
        )
        as(
            path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
            name(id)
        )
    ]
    extent(0,Example.Department)
    comparison(
        binary
        equal
        path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        variable(binary,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(deptname)
        )
        as(
            path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
            name(id)
        )
    ]
    extent(0,Example.Department)
    comparison(
        binary
        equal
        path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        variable(binary,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Department)
    ]
    [
        map(
            deptname
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
        map(
            id
            path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Department)
    ]
    [
        map(
            deptname
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
        map(
            id
            path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e, d from example.employee e, example.department d where e.department = d

Tokens: 
[<SELECT>][e][,][d][<FROM>][example][.][employee][e][,][example][.][department][d][<WHERE>]
[e][.][department][=][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
        as(
            path(any,[property(any,d)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,department)])
        path(any,[property(any,d)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Department),[extent(1,Example.Department)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Department),[extent(1,Example.Department)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
        map(
            1
            path(object(Example.Department),[extent(1,Example.Department)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
        map(
            1
            path(object(Example.Department),[extent(1,Example.Department)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e0, e1, e2, e3 from example.employee e0, example.employee e1, example.employee e2, example.employee e3 where e0 = e1 and e1 = e2 and e2 = e3

Tokens: 
[<SELECT>][e0][,][e1][,][e2][,][e3][<FROM>][example][.][employee][e0][,][example]
[.][employee][e1][,][example][.][employee][e2][,][example][.][employee][e3][<WHERE>][e0]
[=][e1][<AND>][e1][=][e2][<AND>][e2][=][e3]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e0)])
            name(noName)
        )
        as(
            path(any,[property(any,e1)])
            name(noName)
        )
        as(
            path(any,[property(any,e2)])
            name(noName)
        )
        as(
            path(any,[property(any,e3)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            join1(
                inner
                as(
                    extent(any,example.employee)
                    alias(any,e0)
                )
                as(
                    extent(any,example.employee)
                    alias(any,e1)
                )
                literal(logical,true)
            )
            as(
                extent(any,example.employee)
                alias(any,e2)
            )
            literal(logical,true)
        )
        as(
            extent(any,example.employee)
            alias(any,e3)
        )
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e0)])
            path(any,[property(any,e1)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e1)])
                path(any,[property(any,e2)])
            )
            comparison(
                any
                equal
                path(any,[property(any,e2)])
                path(any,[property(any,e3)])
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            join1(
                inner
                extent(0,example.employee)
                extent(1,example.employee)
                literal(logical,true)
            )
            extent(2,example.employee)
            literal(logical,true)
        )
        extent(3,example.employee)
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            path(any,[extent(1,example.employee)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee)])
                path(any,[extent(2,example.employee)])
            )
            comparison(
                any
                equal
                path(any,[extent(2,example.employee)])
                path(any,[extent(3,example.employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,example.employee)
                extent(1,example.employee)
            )
            extent(2,example.employee)
        )
        extent(3,example.employee)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            path(any,[extent(1,example.employee)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee)])
                path(any,[extent(2,example.employee)])
            )
            comparison(
                any
                equal
                path(any,[extent(2,example.employee)])
                path(any,[extent(3,example.employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(1,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(2,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(3,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Employee)
                extent(1,Example.Employee)
            )
            extent(2,Example.Employee)
        )
        extent(3,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(1,Example.Employee)])
                path(object(Example.Employee),[extent(2,Example.Employee)])
            )
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(2,Example.Employee)])
                path(object(Example.Employee),[extent(3,Example.Employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(1,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(2,Example.Employee)])
            name(noName)
        )
        as(
            path(object(Example.Employee),[extent(3,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Employee)
                extent(1,Example.Employee)
            )
            extent(2,Example.Employee)
        )
        extent(3,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(1,Example.Employee)])
                path(object(Example.Employee),[extent(2,Example.Employee)])
            )
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(2,Example.Employee)])
                path(object(Example.Employee),[extent(3,Example.Employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
        map(
            1
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        map(
            2
            path(object(Example.Employee),[extent(2,Example.Employee)])
        )
        map(
            3
            path(object(Example.Employee),[extent(3,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
        map(
            1
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        map(
            2
            path(object(Example.Employee),[extent(2,Example.Employee)])
        )
        map(
            3
            path(object(Example.Employee),[extent(3,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e, example.employee f where e.manager.manager = f

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][,][example][.][employee][f][<WHERE>][e][.]
[manager][.][manager][=][f]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager),property(any,manager)])
        path(any,[property(any,f)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(1,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        extent(2,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(2,Example.Employee)])
        )
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(2,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.department.location = e.manager.department.location

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][department][.][location][=][e]
[.][manager][.][department][.][location]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,department),property(any,location)])
        path(any,[property(any,e),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        equal
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Department),Department),property(object(Example.Location),Location)])
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Employee)
                extent(1,Example.Department)
            )
            extent(2,Example.Employee)
        )
        extent(3,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                path(object(Example.Employee),[extent(2,Example.Employee)])
            )
            operation(
                logical
                and
                comparison(
                    object(Example.Department)
                    equal
                    path(object(Example.Department),[extent(2,Example.Employee),property(object(Example.Department),Department)])
                    path(object(Example.Department),[extent(3,Example.Department)])
                )
                comparison(
                    object(Example.Location)
                    equal
                    path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
                    path(object(Example.Location),[extent(3,Example.Department),property(object(Example.Location),Location)])
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
        extent(2,Example.Employee)
        extent(3,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.manager.department.location is null

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][manager][.][department][.][location]
[<IS>][<NULL>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        is
        path(any,[property(any,e),property(any,manager),property(any,department),property(any,location)])
        literal(any,null)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
        literal(any,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
        literal(any,null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        is
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location)])
        literal(object(Example.Location),null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        is
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location)])
        literal(object(Example.Location),null)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where ? = e.manager.department.location

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][?][0][=][e][.][manager][.]
[department][.][location]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        variable(any,0)
        path(any,[property(any,e),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        variable(any,0)
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        variable(any,0)
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        equal
        variable(object(Example.Location),0)
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        extent(2,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Department)
                equal
                path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
                path(object(Example.Department),[extent(2,Example.Department)])
            )
            comparison(
                object(Example.Location)
                equal
                variable(object(Example.Location),0)
                path(object(Example.Location),[extent(2,Example.Department),property(object(Example.Location),Location)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.manager.department.location = ?

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][manager][.][department][.][location]
[=][?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        equal
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location)])
        variable(object(Example.Location),0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        extent(2,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Department)
                equal
                path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
                path(object(Example.Department),[extent(2,Example.Department)])
            )
            comparison(
                object(Example.Location)
                equal
                path(object(Example.Location),[extent(2,Example.Department),property(object(Example.Location),Location)])
                variable(object(Example.Location),0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where ? = e.department.location

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][?][0][=][e][.][department][.]
[location]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        variable(any,0)
        path(any,[property(any,e),property(any,department),property(any,location)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        variable(any,0)
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        variable(any,0)
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        equal
        variable(object(Example.Location),0)
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Department),Department),property(object(Example.Location),Location)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            object(Example.Location)
            equal
            variable(object(Example.Location),0)
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.department.location = ?

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][department][.][location][=][?]
[0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department),property(any,location)])
        variable(any,0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(Example.Location)
        equal
        path(object(Example.Location),[extent(0,Example.Employee),property(object(Example.Department),Department),property(object(Example.Location),Location)])
        variable(object(Example.Location),0)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            object(Example.Location)
            equal
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
            variable(object(Example.Location),0)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p, d from example.person p, example.department d where cast(p.father as employee).department = d

Tokens: 
[<SELECT>][p][,][d][<FROM>][example][.][person][p][,][example][.][department][d][<WHERE>]
[<CAST>][(][p][.][father][<AS>][employee][)][.][department][=][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
        as(
            path(any,[property(any,d)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.person)
            alias(any,p)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,p),cast(property(any,father),employee),property(any,department)])
        path(any,[property(any,d)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.person)
        extent(1,example.department)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.person),cast(property(any,father),employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.person)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.person),cast(property(any,father),employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
        as(
            path(object(Example.Department),[extent(1,Example.Department)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Person)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
        as(
            path(object(Example.Department),[extent(1,Example.Department)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Person)
            extent(1,Example.Department)
        )
        extent(2,Example.Person)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Person)
            equal
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father)])
            path(object(Example.Person),[extent(2,Example.Person)])
        )
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[cast(extent(2,Example.Person),object(Example.Employee)),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
        map(
            1
            path(object(Example.Department),[extent(1,Example.Department)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
        extent(1,Example.Department)
        extent(2,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
        map(
            1
            path(object(Example.Department),[extent(1,Example.Department)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select sum(e.salaryint32) from employee e where e.manager.firstname = ?

Tokens: 
[<SELECT>][<SUM>][(][e][.][salaryint32][)][<FROM>][employee][e][<WHERE>][e][.][manager][.]
[firstname][=][?][0]

Parse tree: 
select1(
    all
    [
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint32)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager),property(any,firstname)])
        variable(any,0)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    extent(0,employee)
    comparison(
        any
        equal
        path(any,[extent(0,employee),property(any,manager),property(any,firstname)])
        variable(any,0)
    )
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    extent(0,employee)
    comparison(
        any
        equal
        path(any,[extent(0,employee),property(any,manager),property(any,firstname)])
        variable(any,0)
    )
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,0)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(string,FirstName)])
        variable(string,0)
    )
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,0)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(string,FirstName)])
        variable(string,0)
    )
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,0)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,0)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select l.* from example.location l

Tokens: 
[<SELECT>][l][.][*][<FROM>][example][.][location][l]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(any,l),property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,example.location)
        alias(any,l)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.location),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.location),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select l.*, d.* from example.location l join example.department d

Tokens: 
[<SELECT>][l][.][*][,][d][.][*][<FROM>][example][.][location][l][<JOIN>][example]
[.][department][d]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(any,l),property(many,*)])
            name(noName)
        )
        as(
            path(many,[property(any,d),property(many,*)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.location)
            alias(any,l)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.location),property(many,*)])
            name(noName)
        )
        as(
            path(many,[extent(1,example.department),property(many,*)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.location)
        extent(1,example.department)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.location),property(many,*)])
            name(noName)
        )
        as(
            path(many,[extent(1,example.department),property(many,*)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.location)
        extent(1,example.department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Description)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
            name(noName)
        )
        as(
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Description)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
            name(noName)
        )
        as(
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
        map(
            3
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
        map(
            4
            path(string,[extent(1,Example.Department),property(string,Description)])
        )
        map(
            5
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
        )
        map(
            6
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
        map(
            3
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
        map(
            4
            path(string,[extent(1,Example.Department),property(string,Description)])
        )
        map(
            5
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
        )
        map(
            6
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location

Tokens: 
[<SELECT>][*][<FROM>][location]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,location)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location)]),property(many,*)])
            name(noName)
        )
    ]
    extent(0,location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Location)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select * from location join department

Tokens: 
[<SELECT>][*][<FROM>][location][<JOIN>][department]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(many,*)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,location)
            alias(any,noName)
        )
        as(
            extent(any,department)
            alias(any,noName)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location),extent(1,department)]),property(many,*)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,location)
        extent(1,department)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(unspec,[extent(0,location),extent(1,department)]),property(many,*)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,location)
        extent(1,department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Description)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
            name(noName)
        )
        as(
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Location),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Location),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Location),property(integer,Type)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Description)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
            name(noName)
        )
        as(
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
        map(
            3
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
        map(
            4
            path(string,[extent(1,Example.Department),property(string,Description)])
        )
        map(
            5
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
        )
        map(
            6
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Location),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Location),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Location),property(integer,Type)])
        )
        map(
            3
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
        map(
            4
            path(string,[extent(1,Example.Department),property(string,Description)])
        )
        map(
            5
            path(object(Example.Location),[extent(1,Example.Department),property(object(Example.Location),Location)])
        )
        map(
            6
            path(binary,[extent(1,Example.Department),property(binary,IdBinary)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p.father.father.* from example.person p

Tokens: 
[<SELECT>][p][.][father][.][father][.][*][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(any,p),property(any,father),property(any,father),property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.person),property(any,father),property(any,father),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.person),property(any,father),property(any,father),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,LastName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,_Temp)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Location),Home)])
            name(noName)
        )
        as(
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Father)])
            name(noName)
        )
        as(
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Mother)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,LastName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,_Temp)])
            name(noName)
        )
        as(
            path(object(Example.Location),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Location),Home)])
            name(noName)
        )
        as(
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Father)])
            name(noName)
        )
        as(
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Mother)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,LastName)])
        )
        map(
            2
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,_Temp)])
        )
        map(
            3
            path(object(Example.Location),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Location),Home)])
        )
        map(
            4
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Father)])
        )
        map(
            5
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Mother)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,LastName)])
        )
        map(
            2
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(string,_Temp)])
        )
        map(
            3
            path(object(Example.Location),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Location),Home)])
        )
        map(
            4
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Father)])
        )
        map(
            5
            path(object(Example.Person),[extent(0,Example.Person),property(object(Example.Person),Father),property(object(Example.Person),Father),property(object(Example.Person),Mother)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(p.father.father as example.location).* from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][father][.][father][<AS>][example][.][location][)][.][*]
[<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(many,[property(any,p),property(any,father),cast(property(any,father),example.location),property(many,*)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.person),property(any,father),cast(property(any,father),example.location),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(many,[extent(0,example.person),property(any,father),cast(property(any,father),example.location),property(many,*)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Description)])
            name(noName)
        )
        as(
            path(integer,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(integer,Type)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(integer,Type)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(string,Description)])
        )
        map(
            2
            path(integer,[extent(0,Example.Person),property(object(Example.Person),Father),cast(property(object(Example.Person),Father),object(Example.Location)),property(integer,Type)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select e.* as name from employee e

Tokens: 
[<SELECT>][e][.][*][<AS>][name][<FROM>][employee][e]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: neg
Query: 
select cast(p.father.father.* as example.location) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][father][.][father][.][*][<AS>][example][.][location][)]
[<FROM>][example][.][person][p]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: pos
Query: 
select firstname, name from employee join department

Tokens: 
[<SELECT>][firstname][,][name][<FROM>][employee][<JOIN>][department]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,employee)
            alias(any,noName)
        )
        as(
            extent(any,department)
            alias(any,noName)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee),extent(1,department)]),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(unspec,[extent(0,employee),extent(1,department)]),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,employee)
        extent(1,department)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee),extent(1,department)]),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(unspec,[extent(0,employee),extent(1,department)]),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,employee)
        extent(1,department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(father as employee).manager from example.person

Tokens: 
[<SELECT>][<CAST>][(][father][<AS>][employee][)][.][manager][<FROM>][example][.][person]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,father),employee),property(any,manager)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(property(any,father),employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(property(any,father),employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select getextension<myperson>() from example.person

Tokens: 
[<SELECT>][getextension][<][myperson][>][(][)][<FROM>][example][.][person]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Person),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Person),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Person),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Person),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(getextension<myperson>() as employee) from example.person

Tokens: 
[<SELECT>][<CAST>][(][getextension][<][myperson][>][(][)][<AS>][employee][)][<FROM>][example][.]
[person]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(gmethod(any,getextension,[myperson],[]),employee)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(gmethod(any,getextension,[myperson],[]),employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(gmethod(any,getextension,[myperson],[]),employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee))])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee))])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 16
Type: neg
Query: 
select e.firstname from employee

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][employee]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee)]),property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,employee)]),property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,e),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,e),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,e),property(any,firstname)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,e),property(any,firstname)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Unknown property or alias e.
]


Runtime: 0
Type: neg
Query: 
select name from location join department

Tokens: 
[<SELECT>][name][<FROM>][location][<JOIN>][department]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,location)
            alias(any,noName)
        )
        as(
            extent(any,department)
            alias(any,noName)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,location),extent(1,department)]),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,location)
        extent(1,department)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,location),extent(1,department)]),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,location)
        extent(1,department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Location)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Location)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Ambiguous property name.
]


Runtime: 0
Type: neg
Query: 
select getextension<myperson>() from example.person join employee

Tokens: 
[<SELECT>][getextension][<][myperson][>][(][)][<FROM>][example][.][person][<JOIN>][employee]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.person)
            alias(any,noName)
        )
        as(
            extent(any,employee)
            alias(any,noName)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person),extent(1,employee)]),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.person)
        extent(1,employee)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person),extent(1,employee)]),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.person)
        extent(1,employee)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),gmethod(unknown,getextension,[myperson],[])])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Person)
        extent(1,Example.Employee)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),gmethod(unknown,getextension,[myperson],[])])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Person)
        extent(1,Example.Employee)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),gmethod(unknown,getextension,[myperson],[])])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),gmethod(unknown,getextension,[myperson],[])])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Ambiguous method getextension<myperson>().
]


Runtime: 0
Type: pos
Query: 
select e.firstname from employee e

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.getextension<myperson>() from employee e

Tokens: 
[<SELECT>][e][.][getextension][<][myperson][>][(][)][<FROM>][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    as(
        extent(any,employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),gmethod(any,getextension,[myperson],[])])
            name(noName)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select p from person p

Tokens: 
[<SELECT>][p][<FROM>][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,person)])
            name(noName)
        )
    ]
    extent(0,person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,person)])
            name(noName)
        )
    ]
    extent(0,person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(person),[extent(0,person)])
            name(noName)
        )
    ]
    extent(0,person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(person),[extent(0,person)])
            name(noName)
        )
    ]
    extent(0,person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,person)
    ]
    [
        map(
            0
            path(object(person),[extent(0,person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,person)
    ]
    [
        map(
            0
            path(object(person),[extent(0,person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Ambiguous class person.
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname starts with 'st'

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<STARTS>][<WITH>]
['st']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            literal(string,'st')
        )
        comparison(
            any
            lessThan
            path(any,[property(any,e),property(any,firstname)])
            operation(
                string
                addMaxChar
                literal(string,'st')
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'st')
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                literal(string,'st')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'st')
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                literal(string,'st')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'st')
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                literal(string,'st')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'st')
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                literal(string,'st')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname starts with ?

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<STARTS>][<WITH>]
[?][0]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[property(any,e),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            variable(any,0)
        )
        comparison(
            any
            lessThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            operation(
                string
                addMaxChar
                variable(any,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                variable(string,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            variable(string,0)
        )
        comparison(
            string
            lessThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            operation(
                string
                addMaxChar
                variable(string,0)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
1

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(p as example.employee) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][<AS>][example][.][employee][)][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,p),example.employee)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee))])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee))])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(p as example.employee).manager from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][<AS>][example][.][employee][)][.][manager][<FROM>][example][.][person]
[p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,p),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[cast(extent(0,Example.Person),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(p.father as example.employee).manager from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][father][<AS>][example][.][employee][)][.][manager][<FROM>][example]
[.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),cast(property(any,father),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(property(object(Example.Person),Father),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(cast(p as example.employee).manager as example.person).father from example.person p

Tokens: 
[<SELECT>][<CAST>][(][<CAST>][(][p][<AS>][example][.][employee][)][.][manager][<AS>][example]
[.][person][)][.][father][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,p),example.employee),cast(property(any,manager),example.person),property(any,father)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee),cast(property(any,manager),example.person),property(any,father)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.employee),cast(property(any,manager),example.person),property(any,father)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[cast(extent(0,Example.Person),object(Example.Employee)),cast(property(object(Example.Employee),Manager),object(Example.Person)),property(object(Example.Person),Father)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[cast(extent(0,Example.Person),object(Example.Employee)),cast(property(object(Example.Employee),Manager),object(Example.Person)),property(object(Example.Person),Father)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[cast(extent(0,Example.Person),object(Example.Employee)),cast(property(object(Example.Employee),Manager),object(Example.Person)),property(object(Example.Person),Father)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[cast(extent(0,Example.Person),object(Example.Employee)),cast(property(object(Example.Employee),Manager),object(Example.Person)),property(object(Example.Person),Father)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select cast(p.getextension<example.myperson>() as example.employee).manager from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][getextension][<][example][.][myperson][>][(][)][<AS>][example]
[.][employee][)][.][manager][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),cast(gmethod(any,getextension,[example.myperson],[]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(gmethod(any,getextension,[example.myperson],[]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(gmethod(any,getextension,[example.myperson],[]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select cast(q as example.employee) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][q][<AS>][example][.][employee][)][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,q),example.employee)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(property(any,q),example.employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.person)]),cast(property(any,q),example.employee)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(unspec,unknown),cast(property(unknown,q),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(unspec,unknown),cast(property(unknown,q),object(Example.Employee))])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(unspec,unknown),cast(property(unknown,q),object(Example.Employee))])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(unspec,unknown),cast(property(unknown,q),object(Example.Employee))])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Unknown property or alias q.
]


Runtime: 0
Type: neg
Query: 
select cast(p as example.nonexistingclass) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][<AS>][example][.][nonexistingclass][)][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[cast(property(any,p),example.nonexistingclass)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.nonexistingclass)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[cast(extent(0,example.person),example.nonexistingclass)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[cast(extent(0,example.person),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[cast(extent(0,example.person),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[cast(extent(0,example.person),unknown)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[cast(extent(0,example.person),unknown)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Cast to unknown class example.nonexistingclass.
]


Runtime: 0
Type: neg
Query: 
select cast(p.father as string) from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][father][<AS>][string][)][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),cast(property(any,father),string)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),string)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(property(any,father),string)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(unknown,[extent(0,Example.Person),cast(property(object(Example.Person),Father),unknown)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select cast(p.equalsorisderivedfrom(p) as example.employee).manager from example.person p

Tokens: 
[<SELECT>][<CAST>][(][p][.][equalsorisderivedfrom][(][p][)][<AS>][example][.][employee][)][.]
[manager][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),cast(method(any,equalsorisderivedfrom,[path(any,[property(any,p)])]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(method(any,equalsorisderivedfrom,[path(any,[extent(0,example.person)])]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),cast(method(any,equalsorisderivedfrom,[path(any,[extent(0,example.person)])]),example.employee),property(any,manager)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Person),[extent(0,Example.Person)])]),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Person),cast(method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Person),[extent(0,Example.Person)])]),object(Example.Employee)),property(object(Example.Employee),Manager)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Person),[extent(0,Example.Person)])]),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Person),cast(method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Person),[extent(0,Example.Person)])]),object(Example.Employee)),property(object(Example.Employee),Manager)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Unsupported cast from boolean to object(Example.Employee).
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e = object 123

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][=][<OBJECT>][123]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e)])
        literal(object(unknown),123)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee)])
        literal(object(unknown),123)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee)])
        literal(object(unknown),123)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee)])
        literal(object(unknown),123)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee)])
        literal(object(unknown),123)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e join example.department d on e.department = d where e = object 123

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<JOIN>][example]
[.][department][d][<ON>][e][.][department][=][d][<WHERE>][e][=][<OBJECT>][123]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,department)])
            path(any,[property(any,d)])
        )
    )
    comparison(
        any
        equal
        path(any,[property(any,e)])
        literal(object(unknown),123)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,department)])
            path(any,[extent(1,example.department)])
        )
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee)])
        literal(object(unknown),123)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,department)])
            path(any,[extent(1,example.department)])
        )
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            literal(object(unknown),123)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            object(unknown)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            literal(object(unknown),123)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            object(unknown)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            literal(object(unknown),123)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select d from department d where d.idbinary = binary 'ffff'

Tokens: 
[<SELECT>][d][<FROM>][department][d][<WHERE>][d][.][idbinary][=][<BINARY>]['ffff']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,d)])
            name(noName)
        )
    ]
    as(
        extent(any,department)
        alias(any,d)
    )
    comparison(
        any
        equal
        path(any,[property(any,d),property(any,idbinary)])
        literal(binary,'ffff')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,department)])
            name(noName)
        )
    ]
    extent(0,department)
    comparison(
        any
        equal
        path(any,[extent(0,department),property(any,idbinary)])
        literal(binary,'ffff')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,department)])
            name(noName)
        )
    ]
    extent(0,department)
    comparison(
        any
        equal
        path(any,[extent(0,department),property(any,idbinary)])
        literal(binary,'ffff')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Department),[extent(0,Example.Department)])
            name(noName)
        )
    ]
    extent(0,Example.Department)
    comparison(
        binary
        equal
        path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        literal(binary,'ffff')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Department),[extent(0,Example.Department)])
            name(noName)
        )
    ]
    extent(0,Example.Department)
    comparison(
        binary
        equal
        path(binary,[extent(0,Example.Department),property(binary,IdBinary)])
        literal(binary,'ffff')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Department),[extent(0,Example.Department)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Department)
    ]
    [
        map(
            0
            path(object(Example.Department),[extent(0,Example.Department)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.department d join example.employee e where e.firstname <= 'peter' and e.department.name = d.name and e.firstname >'b' option join order (e,d)

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][department][d][<JOIN>][example]
[.][employee][e][<WHERE>][e][.][firstname][<=]['peter'][<AND>][e][.][department][.][name]
[=][d][.][name][<AND>][e][.][firstname][>]['b'][<OPTION>][<JOIN>][<ORDER>][(][e]
[,][d][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.department)
            alias(any,d)
        )
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e),property(any,department),property(any,name)])
                path(any,[property(any,d),property(any,name)])
            )
            comparison(
                any
                greaterThan
                path(any,[property(any,e),property(any,firstname)])
                literal(string,'b')
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([alias(any,e),alias(any,d)])
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.department)
        extent(1,example.employee)
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(1,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee),property(any,department),property(any,name)])
                path(any,[extent(0,example.department),property(any,name)])
            )
            comparison(
                any
                greaterThan
                path(any,[extent(1,example.employee),property(any,firstname)])
                literal(string,'b')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,example.employee),extent(0,example.department)])
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.department)
        extent(1,example.employee)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(1,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee),property(any,department),property(any,name)])
                path(any,[extent(0,example.department),property(any,name)])
            )
            comparison(
                any
                greaterThan
                path(any,[extent(1,example.employee),property(any,firstname)])
                literal(string,'b')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,example.employee),extent(0,example.department)])
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Department)
        extent(1,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                string
                equal
                path(string,[extent(1,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                path(string,[extent(0,Example.Department),property(string,Name)])
            )
            comparison(
                string
                greaterThan
                path(string,[extent(1,Example.Employee),property(string,FirstName)])
                literal(string,'b')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,Example.Employee),extent(0,Example.Department)])
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Department)
            extent(1,Example.Employee)
        )
        extent(2,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            operation(
                logical
                and
                comparison(
                    object(Example.Department)
                    equal
                    path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
                    path(object(Example.Department),[extent(2,Example.Department)])
                )
                comparison(
                    string
                    equal
                    path(string,[extent(2,Example.Department),property(string,Name)])
                    path(string,[extent(0,Example.Department),property(string,Name)])
                )
            )
            comparison(
                string
                greaterThan
                path(string,[extent(1,Example.Employee),property(string,FirstName)])
                literal(string,'b')
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,Example.Employee),extent(0,Example.Department)])
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
        extent(2,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.department d join example.employee e join example.location l where e.firstname <= 'peter' and l.name = 'stockholm' and e.department.name = d.name and d.location = l and e.firstname >'b' option join order (e,d,l)

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][department][d][<JOIN>][example]
[.][employee][e][<JOIN>][example][.][location][l][<WHERE>][e][.][firstname][<=]['peter'][<AND>]
[l][.][name][=]['stockholm'][<AND>][e][.][department][.][name][=][d][.][name]
[<AND>][d][.][location][=][l][<AND>][e][.][firstname][>]['b'][<OPTION>][<JOIN>][<ORDER>]
[(][e][,][d][,][l][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            as(
                extent(any,example.department)
                alias(any,d)
            )
            as(
                extent(any,example.employee)
                alias(any,e)
            )
            literal(logical,true)
        )
        as(
            extent(any,example.location)
            alias(any,l)
        )
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,l),property(any,name)])
                literal(string,'stockholm')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[property(any,e),property(any,department),property(any,name)])
                    path(any,[property(any,d),property(any,name)])
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[property(any,d),property(any,location)])
                        path(any,[property(any,l)])
                    )
                    comparison(
                        any
                        greaterThan
                        path(any,[property(any,e),property(any,firstname)])
                        literal(string,'b')
                    )
                )
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([alias(any,e),alias(any,d),alias(any,l)])
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            extent(0,example.department)
            extent(1,example.employee)
            literal(logical,true)
        )
        extent(2,example.location)
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(1,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(2,example.location),property(any,name)])
                literal(string,'stockholm')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(1,example.employee),property(any,department),property(any,name)])
                    path(any,[extent(0,example.department),property(any,name)])
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.department),property(any,location)])
                        path(any,[extent(2,example.location)])
                    )
                    comparison(
                        any
                        greaterThan
                        path(any,[extent(1,example.employee),property(any,firstname)])
                        literal(string,'b')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,example.employee),extent(0,example.department),extent(2,example.location)])
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,example.department)
            extent(1,example.employee)
        )
        extent(2,example.location)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(1,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(2,example.location),property(any,name)])
                literal(string,'stockholm')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(1,example.employee),property(any,department),property(any,name)])
                    path(any,[extent(0,example.department),property(any,name)])
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.department),property(any,location)])
                        path(any,[extent(2,example.location)])
                    )
                    comparison(
                        any
                        greaterThan
                        path(any,[extent(1,example.employee),property(any,firstname)])
                        literal(string,'b')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,example.employee),extent(0,example.department),extent(2,example.location)])
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Department)
            extent(1,Example.Employee)
        )
        extent(2,Example.Location)
    )
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                string
                equal
                path(string,[extent(2,Example.Location),property(string,Name)])
                literal(string,'stockholm')
            )
            operation(
                logical
                and
                comparison(
                    string
                    equal
                    path(string,[extent(1,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                    path(string,[extent(0,Example.Department),property(string,Name)])
                )
                operation(
                    logical
                    and
                    comparison(
                        object(Example.Location)
                        equal
                        path(object(Example.Location),[extent(0,Example.Department),property(object(Example.Location),Location)])
                        path(object(Example.Location),[extent(2,Example.Location)])
                    )
                    comparison(
                        string
                        greaterThan
                        path(string,[extent(1,Example.Employee),property(string,FirstName)])
                        literal(string,'b')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,Example.Employee),extent(0,Example.Department),extent(2,Example.Location)])
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Department)
                extent(1,Example.Employee)
            )
            extent(2,Example.Location)
        )
        extent(3,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                string
                equal
                path(string,[extent(2,Example.Location),property(string,Name)])
                literal(string,'stockholm')
            )
            operation(
                logical
                and
                operation(
                    logical
                    and
                    comparison(
                        object(Example.Department)
                        equal
                        path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
                        path(object(Example.Department),[extent(3,Example.Department)])
                    )
                    comparison(
                        string
                        equal
                        path(string,[extent(3,Example.Department),property(string,Name)])
                        path(string,[extent(0,Example.Department),property(string,Name)])
                    )
                )
                operation(
                    logical
                    and
                    comparison(
                        object(Example.Location)
                        equal
                        path(object(Example.Location),[extent(0,Example.Department),property(object(Example.Location),Location)])
                        path(object(Example.Location),[extent(2,Example.Location)])
                    )
                    comparison(
                        string
                        greaterThan
                        path(string,[extent(1,Example.Employee),property(string,FirstName)])
                        literal(string,'b')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        joinOrderHint([extent(1,Example.Employee),extent(0,Example.Department),extent(2,Example.Location)])
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
        extent(2,Example.Location)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
        extent(2,Example.Location)
        extent(3,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname <= 'peter' and e.lastname >'b' option index (e myindex)

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<=]['peter']
[<AND>][e][.][lastname][>]['b'][<OPTION>][<INDEX>][(][e][myindex][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            literal(string,'peter')
        )
        comparison(
            any
            greaterThan
            path(any,[property(any,e),property(any,lastname)])
            literal(string,'b')
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(alias(any,e),indexName(myindex))
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        comparison(
            any
            greaterThan
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'b')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        comparison(
            any
            greaterThan
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'b')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        comparison(
            string
            greaterThan
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'b')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
        comparison(
            string
            greaterThan
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'b')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname = 'peter' order by e.lastname desc option index(e myindex)

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][=]['peter']
[<ORDER>][<BY>][e][.][lastname][<DESC>][<OPTION>][<INDEX>][(][e][myindex][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,lastname)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(alias(any,e),indexName(myindex))
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'peter')
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'peter')
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e join example.department d on e.department = d where e.firstname = 'peter' order by d.name desc option index(e myindex)

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<JOIN>][example]
[.][department][d][<ON>][e][.][department][=][d][<WHERE>][e][.][firstname][=]['peter']
[<ORDER>][<BY>][d][.][name][<DESC>][<OPTION>][<INDEX>][(][e][myindex][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,department)])
            path(any,[property(any,d)])
        )
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,d),property(any,name)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(alias(any,e),indexName(myindex))
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,department)])
            path(any,[extent(1,example.department)])
        )
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
        sortSpec(
            any
            path(any,[extent(1,example.department),property(any,name)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,department)])
            path(any,[extent(1,example.department)])
        )
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
    )
    [
        sortSpec(
            any
            path(any,[extent(1,example.department),property(any,name)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
    )
    [
        sortSpec(
            string
            path(string,[extent(1,Example.Department),property(string,Name)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Department)
            equal
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            path(object(Example.Department),[extent(1,Example.Department)])
        )
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'peter')
        )
    )
    [
        sortSpec(
            string
            path(string,[extent(1,Example.Department),property(string,Name)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select e.firstname, d.name from example.employee e right join example.department d on e.department = d option join order fixed

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<RIGHT>][<JOIN>]
[example][.][department][d][<ON>][e][.][department][=][d][<OPTION>][<JOIN>][<ORDER>][<FIXED>]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: neg
Query: 
select e, m, d, l from example.department d join example.employee e left join (example.employee m join example.location l) option join order fixed

Tokens: 
[<SELECT>][e][,][m][,][d][,][l][<FROM>][example][.][department][d][<JOIN>][example]
[.][employee][e][<LEFT>][<JOIN>][(][example][.][employee][m][<JOIN>][example][.][location][l]
[)][<OPTION>][<JOIN>][<ORDER>][<FIXED>]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: pos
Query: 
select p._temp from example.person p

Tokens: 
[<SELECT>][p][.][_temp][<FROM>][example][.][person][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),property(any,_temp)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),property(any,_temp)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),property(any,_temp)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(string,_Temp)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(string,_Temp)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(string,_Temp)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Person),property(string,_Temp)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.manager.manager.department.location.name from example.employee e

Tokens: 
[<SELECT>][e][.][manager][.][manager][.][department][.][location][.][name][<FROM>][example][.]
[employee][e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,manager),property(any,manager),property(any,department),property(any,location),property(any,name)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,manager),property(any,manager),property(any,department),property(any,location),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,manager),property(any,manager),property(any,department),property(any,location),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location),property(string,Name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location),property(string,Name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager),property(object(Example.Department),Department),property(object(Example.Location),Location),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 


Tokens: 

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 0
Type: neg
Query: 
select example.employee.department.name from example.employee where example.employee.firstname = 'peter'

Tokens: 
[<SELECT>][example][.][employee][.][department][.][name][<FROM>][example][.][employee][<WHERE>][example][.]
[employee][.][firstname][=]['peter']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,example),property(any,employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,noName)
    )
    comparison(
        any
        equal
        path(any,[property(any,example),property(any,employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.employee)]),property(any,example),property(any,employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(unspec,[extent(0,example.employee)]),property(any,example),property(any,employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(unspec,[extent(0,example.employee)]),property(any,example),property(any,employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(unspec,[extent(0,example.employee)]),property(any,example),property(any,employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        unknown
        equal
        path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        unknown
        equal
        path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,firstname)])
        literal(string,'peter')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,department),property(any,name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(unknown,[extent(unspec,unknown),property(unknown,example),property(any,employee),property(any,department),property(any,name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Unknown property or alias example.
]


Runtime: 0
Type: neg
Query: 
select e.firstname name, e.lastname name from employee e

Tokens: 
[<SELECT>][e][.][firstname][name][,][e][.][lastname][name][<FROM>][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(name)
        )
        as(
            path(any,[property(any,e),property(any,lastname)])
            name(name)
        )
    ]
    as(
        extent(any,employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),property(any,firstname)])
            name(name)
        )
        as(
            path(any,[extent(0,employee),property(any,lastname)])
            name(name)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,employee),property(any,firstname)])
            name(name)
        )
        as(
            path(any,[extent(0,employee),property(any,lastname)])
            name(name)
        )
    ]
    extent(0,employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(name)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(name)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(name)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(name)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            name
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            name
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            name
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            name
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Non-unique column name name.
]


Runtime: 0
Type: pos
Query: 
select e.firstname, f.firstname from example.employee e join example.employee f where e.equalsorisderivedfrom(f) = true

Tokens: 
[<SELECT>][e][.][firstname][,][f][.][firstname][<FROM>][example][.][employee][e][<JOIN>][example]
[.][employee][f][<WHERE>][e][.][equalsorisderivedfrom][(][f][)][=][<TRUE>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,f),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),method(any,equalsorisderivedfrom,[path(any,[property(any,f)])])])
        literal(boolean,true)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),method(any,equalsorisderivedfrom,[path(any,[extent(1,example.employee)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),method(any,equalsorisderivedfrom,[path(any,[extent(1,example.employee)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Employee),[extent(1,Example.Employee)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Employee),[extent(1,Example.Employee)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, f.firstname from example.employee e join example.employee f where e.manager.equalsorisderivedfrom(f.manager) = true

Tokens: 
[<SELECT>][e][.][firstname][,][f][.][firstname][<FROM>][example][.][employee][e][<JOIN>][example]
[.][employee][f][<WHERE>][e][.][manager][.][equalsorisderivedfrom][(][f][.][manager][)][=]
[<TRUE>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,f),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager),method(any,equalsorisderivedfrom,[path(any,[property(any,f),property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),method(any,equalsorisderivedfrom,[path(any,[extent(1,example.employee),property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),method(any,equalsorisderivedfrom,[path(any,[extent(1,example.employee),property(any,manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),property(object(Example.Employee),Manager),method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Employee),[extent(1,Example.Employee),property(object(Example.Employee),Manager)])])])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        extent(2,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(2,Example.Employee)])
        )
        comparison(
            boolean
            equal
            path(boolean,[extent(2,Example.Employee),method(boolean,EqualsOrIsDerivedFrom,[path(object(Example.Employee),[extent(1,Example.Employee),property(object(Example.Employee),Manager)])])])
            literal(boolean,true)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 16
Type: pos
Query: 
select e.getextension<example.myperson>() from example.employee e

Tokens: 
[<SELECT>][e][.][getextension][<][example][.][myperson][>][(][)][<FROM>][example][.][employee]
[e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),gmethod(any,getextension,[example.myperson],[])])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[])])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.MyPerson),[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[])])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.getextension<example.myperson>().myid from example.employee e

Tokens: 
[<SELECT>][e][.][getextension][<][example][.][myperson][>][(][)][.][myid][<FROM>][example]
[.][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),gmethod(any,getextension,[example.myperson],[]),property(any,myid)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myid)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myid)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(integer,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(integer,MyId)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(integer,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(integer,MyId)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(integer,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(integer,MyId)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(integer,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(integer,MyId)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, e.hiredate from example.employee e where e.hiredate = date '2006-10-30'

Tokens: 
[<SELECT>][e][.][firstname][,][e][.][hiredate][<FROM>][example][.][employee][e][<WHERE>][e]
[.][hiredate][=][<DATE>]['2006-10-30']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e),property(any,hiredate)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,hiredate)])
        literal(datetime,'2006-10-30')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,hiredate)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,hiredate)])
        literal(datetime,'2006-10-30')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,hiredate)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,hiredate)])
        literal(datetime,'2006-10-30')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        datetime
        equal
        path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
        literal(datetime,'2006-10-30')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        datetime
        equal
        path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
        literal(datetime,'2006-10-30')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.manager = e.department

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][manager][=][e]
[.][department]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager)])
        path(any,[property(any,e),property(any,department)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee),property(any,department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee),property(any,department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.commission = true

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][commission][=][<TRUE>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.firstname is null and e.manager = null and e.hiredate > null

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<IS>][<NULL>][<AND>][e]
[.][manager][=][<NULL>][<AND>][e][.][hiredate][>][<NULL>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            is
            path(any,[property(any,e),property(any,firstname)])
            literal(any,null)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e),property(any,manager)])
                literal(any,null)
            )
            comparison(
                any
                greaterThan
                path(any,[property(any,e),property(any,hiredate)])
                literal(any,null)
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            is
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(any,null)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,manager)])
                literal(any,null)
            )
            comparison(
                any
                greaterThan
                path(any,[extent(0,example.employee),property(any,hiredate)])
                literal(any,null)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            is
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(any,null)
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,manager)])
                literal(any,null)
            )
            comparison(
                any
                greaterThan
                path(any,[extent(0,example.employee),property(any,hiredate)])
                literal(any,null)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            is
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,null)
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                literal(object(Example.Employee),null)
            )
            comparison(
                datetime
                greaterThan
                path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                literal(datetime,null)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            is
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,null)
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                literal(object(Example.Employee),null)
            )
            comparison(
                datetime
                greaterThan
                path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
                literal(datetime,null)
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where null is null order by e.manager desc

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][<NULL>][<IS>][<NULL>][<ORDER>][<BY>]
[e][.][manager][<DESC>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        is
        literal(any,null)
        literal(any,null)
    )
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,manager)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        literal(any,null)
        literal(any,null)
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,manager)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        is
        literal(any,null)
        literal(any,null)
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,manager)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        is
        literal(string,null)
        literal(string,null)
    )
    [
        sortSpec(
            object(Example.Employee)
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        is
        literal(string,null)
        literal(string,null)
    )
    [
        sortSpec(
            object(Example.Employee)
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            desc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname like 'p%et_er'

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<LIKE>]['p%et_er']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        like
        path(any,[property(any,e),property(any,firstname)])
        literal(string,'p%et_er')
        literal(string,'')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        like
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'p%et_er')
        literal(string,'')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        like
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'p%et_er')
        literal(string,'')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        like
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'p%et_er')
        literal(string,'')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        like
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'p%et_er')
        literal(string,'')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname like 'p7_te7%' escape '7'

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<LIKE>]['p7_te7%']
[<ESCAPE>]['7']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        like
        path(any,[property(any,e),property(any,firstname)])
        literal(string,'p7_te7%')
        literal(string,'7')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        like
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'p7_te7%')
        literal(string,'7')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        like
        path(any,[extent(0,example.employee),property(any,firstname)])
        literal(string,'p7_te7%')
        literal(string,'7')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        like
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'p7_te7%')
        literal(string,'7')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        like
        path(string,[extent(0,Example.Employee),property(string,FirstName)])
        literal(string,'p7_te7%')
        literal(string,'7')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select e.firstname from example.employee e where e.firstname in ('peter','erik')

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<IN>][(]
['peter'][,]['erik'][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    inPredicate(
        path(any,[property(any,e),property(any,firstname)])
        [
            literal(string,'peter')
            literal(string,'erik')
        ]
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    inPredicate(
        path(any,[extent(0,example.employee),property(any,firstname)])
        [
            literal(string,'peter')
            literal(string,'erik')
        ]
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    inPredicate(
        path(any,[extent(0,example.employee),property(any,firstname)])
        [
            literal(string,'peter')
            literal(string,'erik')
        ]
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    inPredicate(
        path(any,[extent(0,example.employee),property(any,firstname)])
        [
            literal(string,'peter')
            literal(string,'erik')
        ]
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    inPredicate(
        path(any,[extent(0,example.employee),property(any,firstname)])
        [
            literal(string,'peter')
            literal(string,'erik')
        ]
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    The in-predicate is not supported.
]


Runtime: 0
Type: pos
Query: 
select e.department.name || ' ' || e.firstname, e.salarysingle * 2 / -1 from example.employee e where e.salarydecimal * + +1.25 = - +2e+3 - e.salaryuint16 and e.manager = e

Tokens: 
[<SELECT>][e][.][department][.][name][||][' '][||][e][.][firstname][,][e][.]
[salarysingle][*][2][/][-][1][<FROM>][example][.][employee][e][<WHERE>][e][.][salarydecimal]
[*][+][+][1][.][25][=][-][+][2][<E>][+][3][-][e]
[.][salaryuint16][<AND>][e][.][manager][=][e]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                string
                concatenation
                path(any,[property(any,e),property(any,department),property(any,name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(any,[property(any,e),property(any,firstname)])
                )
            )
            name(noName)
        )
        as(
            operation(
                numerical
                division
                operation(
                    numerical
                    multiplication
                    path(any,[property(any,e),property(any,salarysingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            operation(
                numerical
                multiplication
                path(any,[property(any,e),property(any,salarydecimal)])
                operation(
                    numerical
                    plus
                    literal(decimal,+1.25)
                )
            )
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    minus
                    literal(double,+2E+3)
                )
                path(any,[property(any,e),property(any,salaryuint16)])
            )
        )
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,manager)])
            path(any,[property(any,e)])
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                string
                concatenation
                path(any,[extent(0,example.employee),property(any,department),property(any,name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(any,[extent(0,example.employee),property(any,firstname)])
                )
            )
            name(noName)
        )
        as(
            operation(
                numerical
                division
                operation(
                    numerical
                    multiplication
                    path(any,[extent(0,example.employee),property(any,salarysingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            operation(
                numerical
                multiplication
                path(any,[extent(0,example.employee),property(any,salarydecimal)])
                operation(
                    numerical
                    plus
                    literal(decimal,+1.25)
                )
            )
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    minus
                    literal(double,+2E+3)
                )
                path(any,[extent(0,example.employee),property(any,salaryuint16)])
            )
        )
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,manager)])
            path(any,[extent(0,example.employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                string
                concatenation
                path(any,[extent(0,example.employee),property(any,department),property(any,name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(any,[extent(0,example.employee),property(any,firstname)])
                )
            )
            name(noName)
        )
        as(
            operation(
                numerical
                division
                operation(
                    numerical
                    multiplication
                    path(any,[extent(0,example.employee),property(any,salarysingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            operation(
                numerical
                multiplication
                path(any,[extent(0,example.employee),property(any,salarydecimal)])
                operation(
                    numerical
                    plus
                    literal(decimal,+1.25)
                )
            )
            operation(
                numerical
                subtraction
                operation(
                    numerical
                    minus
                    literal(double,+2E+3)
                )
                path(any,[extent(0,example.employee),property(any,salaryuint16)])
            )
        )
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,manager)])
            path(any,[extent(0,example.employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                string
                concatenation
                path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                )
            )
            name(noName)
        )
        as(
            operation(
                double
                division
                operation(
                    double
                    multiplication
                    path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            double
            equal
            operation(
                decimal
                multiplication
                path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
                operation(
                    decimal
                    plus
                    literal(decimal,+1.25)
                )
            )
            operation(
                double
                subtraction
                operation(
                    double
                    minus
                    literal(double,+2E+3)
                )
                path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt16)])
            )
        )
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                string
                concatenation
                path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                )
            )
            name(noName)
        )
        as(
            operation(
                double
                division
                operation(
                    double
                    multiplication
                    path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            double
            equal
            operation(
                decimal
                multiplication
                path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
                operation(
                    decimal
                    plus
                    literal(decimal,+1.25)
                )
            )
            operation(
                double
                subtraction
                operation(
                    double
                    minus
                    literal(double,+2E+3)
                )
                path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt16)])
            )
        )
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                string
                concatenation
                path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                )
            )
        )
        map(
            1
            operation(
                double
                division
                operation(
                    double
                    multiplication
                    path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                string
                concatenation
                path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
                operation(
                    string
                    concatenation
                    literal(string,' ')
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                )
            )
        )
        map(
            1
            operation(
                double
                division
                operation(
                    double
                    multiplication
                    path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                    literal(integer,2)
                )
                literal(integer,-1)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select -(-(-e.salaryint64)) * 3 from example.employee e

Tokens: 
[<SELECT>][-][(][-][(][-][e][.][salaryint64][)][)][*][3][<FROM>][example]
[.][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    minus
                    operation(
                        numerical
                        minus
                        operation(
                            numerical
                            minus
                            path(any,[property(any,e),property(any,salaryint64)])
                        )
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    minus
                    operation(
                        numerical
                        minus
                        operation(
                            numerical
                            minus
                            path(any,[extent(0,example.employee),property(any,salaryint64)])
                        )
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            operation(
                numerical
                multiplication
                operation(
                    numerical
                    minus
                    operation(
                        numerical
                        minus
                        operation(
                            numerical
                            minus
                            path(any,[extent(0,example.employee),property(any,salaryint64)])
                        )
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            operation(
                integer
                multiplication
                operation(
                    integer
                    minus
                    operation(
                        integer
                        minus
                        operation(
                            integer
                            minus
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                        )
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            operation(
                integer
                multiplication
                operation(
                    integer
                    minus
                    operation(
                        integer
                        minus
                        operation(
                            integer
                            minus
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                        )
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                multiplication
                operation(
                    integer
                    minus
                    operation(
                        integer
                        minus
                        operation(
                            integer
                            minus
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                        )
                    )
                )
                literal(integer,3)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            operation(
                integer
                multiplication
                operation(
                    integer
                    minus
                    operation(
                        integer
                        minus
                        operation(
                            integer
                            minus
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                        )
                    )
                )
                literal(integer,3)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select sum(e.salaryint32) * (2 + 'b') from example.employee e

Tokens: 
[<SELECT>][<SUM>][(][e][.][salaryint32][)][*][(][2][+]['b'][)][<FROM>][example]
[.][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                multiplication
                setFunction(
                    sum
                    all
                    path(any,[property(any,e),property(any,salaryint32)])
                )
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer])
    ]
    [
        map(
            0
            operation(
                numerical
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer])
    ]
    [
        map(
            0
            operation(
                numerical
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                operation(
                    numerical
                    addition
                    literal(integer,2)
                    literal(string,'b')
                )
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Incorrect arguments of types integer and string to operator addition.
]


Runtime: 0
Type: pos
Query: 
select e.firstname fname from example.employee e order by random

Tokens: 
[<SELECT>][e][.][firstname][fname][<FROM>][example][.][employee][e][<ORDER>][<BY>][<RANDOM>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(fname)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
        random
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(fname)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        random
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(fname)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        random
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(fname)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        random
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(fname)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        random
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            fname
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            fname
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e order by e.department.name, e.firstname, e.lastname

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<ORDER>][<BY>][e][.][department][.]
[name][,][e][.][firstname][,][e][.][lastname]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,department),property(any,name)])
            asc
        )
        sortSpec(
            any
            path(any,[property(any,e),property(any,firstname)])
            asc
        )
        sortSpec(
            any
            path(any,[property(any,e),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,department),property(any,name)])
            asc
        )
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,firstname)])
            asc
        )
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,department),property(any,name)])
            asc
        )
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,firstname)])
            asc
        )
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
            asc
        )
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            asc
        )
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
            asc
        )
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            asc
        )
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p from example.person p order by p

Tokens: 
[<SELECT>][p][<FROM>][example][.][person][p][<ORDER>][<BY>][p]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p)])
            name(noName)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,p)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.person)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person)])
            name(noName)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.person)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Person)
            path(object(Example.Person),[extent(0,Example.Person)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Person),[extent(0,Example.Person)])
            name(noName)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Person)
            path(object(Example.Person),[extent(0,Example.Person)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            0
            path(object(Example.Person),[extent(0,Example.Person)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select p.firstname fname from example.person p order by p.firstname

Tokens: 
[<SELECT>][p][.][firstname][fname][<FROM>][example][.][person][p][<ORDER>][<BY>][p][.][firstname]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,p),property(any,firstname)])
            name(fname)
        )
    ]
    as(
        extent(any,example.person)
        alias(any,p)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,p),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),property(any,firstname)])
            name(fname)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.person),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.person),property(any,firstname)])
            name(fname)
        )
    ]
    extent(0,example.person)
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[extent(0,example.person),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(string,FirstName)])
            name(fname)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Person),property(string,FirstName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Person),property(string,FirstName)])
            name(fname)
        )
    ]
    extent(0,Example.Person)
    literal(logical,true)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Person),property(string,FirstName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            fname
            path(string,[extent(0,Example.Person),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Person)
    ]
    [
        map(
            fname
            path(string,[extent(0,Example.Person),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e join example.department d on e.department = d

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<JOIN>][example]
[.][department][d][<ON>][e][.][department][=][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,department)])
            path(any,[property(any,d)])
        )
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,department)])
            path(any,[extent(1,example.department)])
        )
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e join example.department d where e.department = d

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<JOIN>][example]
[.][department][d][<WHERE>][e][.][department][=][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,department)])
        path(any,[property(any,d)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e join example.department d on e = d

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<JOIN>][example]
[.][department][d][<ON>][e][=][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        comparison(
            any
            equal
            path(any,[property(any,e)])
            path(any,[property(any,d)])
        )
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            path(any,[extent(1,example.department)])
        )
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee)])
        path(any,[extent(1,example.department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(unknown)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, d.name from example.employee e cross join example.department d

Tokens: 
[<SELECT>][e][.][firstname][,][d][.][name][<FROM>][example][.][employee][e][<CROSS>][<JOIN>]
[example][.][department][d]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
    ]
    join1(
        cross
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join1(
        cross
        extent(0,example.employee)
        extent(1,example.department)
        literal(logical,true)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.department),property(any,name)])
            name(noName)
        )
    ]
    join2(
        cross
        extent(0,example.employee)
        extent(1,example.department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        cross
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Department),property(string,Name)])
            name(noName)
        )
    ]
    join2(
        cross
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, f.firstname from example.employee e left outer join example.employee f where e.manager = f

Tokens: 
[<SELECT>][e][.][firstname][,][f][.][firstname][<FROM>][example][.][employee][e][<LEFT>][<OUTER>]
[<JOIN>][example][.][employee][f][<WHERE>][e][.][manager][=][f]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,f),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        left
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager)])
        path(any,[property(any,f)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        left
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        left
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        left
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(1,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        left
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(1,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e0.firstname, e1.firstname, e2.firstname, e3.firstname from example.employee e0 join example.employee e1 join (example.employee e2 join example.employee e3) where e0 = e1 and e1 = e2 and e2 = e3

Tokens: 
[<SELECT>][e0][.][firstname][,][e1][.][firstname][,][e2][.][firstname][,][e3][.]
[firstname][<FROM>][example][.][employee][e0][<JOIN>][example][.][employee][e1][<JOIN>][(][example][.]
[employee][e2][<JOIN>][example][.][employee][e3][)][<WHERE>][e0][=][e1][<AND>][e1][=]
[e2][<AND>][e2][=][e3]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e0),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e1),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e2),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e3),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            as(
                extent(any,example.employee)
                alias(any,e0)
            )
            as(
                extent(any,example.employee)
                alias(any,e1)
            )
            literal(logical,true)
        )
        join1(
            inner
            as(
                extent(any,example.employee)
                alias(any,e2)
            )
            as(
                extent(any,example.employee)
                alias(any,e3)
            )
            literal(logical,true)
        )
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e0)])
            path(any,[property(any,e1)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e1)])
                path(any,[property(any,e2)])
            )
            comparison(
                any
                equal
                path(any,[property(any,e2)])
                path(any,[property(any,e3)])
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            extent(0,example.employee)
            extent(1,example.employee)
            literal(logical,true)
        )
        join1(
            inner
            extent(2,example.employee)
            extent(3,example.employee)
            literal(logical,true)
        )
        literal(logical,true)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            path(any,[extent(1,example.employee)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee)])
                path(any,[extent(2,example.employee)])
            )
            comparison(
                any
                equal
                path(any,[extent(2,example.employee)])
                path(any,[extent(3,example.employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,example.employee)
            extent(1,example.employee)
        )
        join2(
            inner
            extent(2,example.employee)
            extent(3,example.employee)
        )
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee)])
            path(any,[extent(1,example.employee)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee)])
                path(any,[extent(2,example.employee)])
            )
            comparison(
                any
                equal
                path(any,[extent(2,example.employee)])
                path(any,[extent(3,example.employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        join2(
            inner
            extent(2,Example.Employee)
            extent(3,Example.Employee)
        )
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(1,Example.Employee)])
                path(object(Example.Employee),[extent(2,Example.Employee)])
            )
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(2,Example.Employee)])
                path(object(Example.Employee),[extent(3,Example.Employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        join2(
            inner
            extent(2,Example.Employee)
            extent(3,Example.Employee)
        )
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(1,Example.Employee)])
                path(object(Example.Employee),[extent(2,Example.Employee)])
            )
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(2,Example.Employee)])
                path(object(Example.Employee),[extent(3,Example.Employee)])
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
        )
        map(
            3
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
        )
        map(
            3
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname, f.firstname from example.employee f right outer join example.employee e where e.manager = f

Tokens: 
[<SELECT>][e][.][firstname][,][f][.][firstname][<FROM>][example][.][employee][f][<RIGHT>][<OUTER>]
[<JOIN>][example][.][employee][e][<WHERE>][e][.][manager][=][f]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,f),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        right
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager)])
        path(any,[property(any,f)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        right
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(1,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        right
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(1,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        right
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(1,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(0,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        right
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(1,Example.Employee),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(0,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e join example.employee f where e.manager.manager = f

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<JOIN>][example][.][employee][f][<WHERE>][e][.]
[manager][.][manager][=][f]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.employee)
            alias(any,f)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,manager),property(any,manager)])
        path(any,[property(any,f)])
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,manager),property(any,manager)])
        path(any,[extent(1,example.employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Employee)
        equal
        path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager),property(object(Example.Employee),Manager)])
        path(object(Example.Employee),[extent(1,Example.Employee)])
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            extent(0,Example.Employee)
            extent(1,Example.Employee)
        )
        extent(2,Example.Employee)
    )
    operation(
        logical
        and
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(2,Example.Employee)])
        )
        comparison(
            object(Example.Employee)
            equal
            path(object(Example.Employee),[extent(2,Example.Employee),property(object(Example.Employee),Manager)])
            path(object(Example.Employee),[extent(1,Example.Employee)])
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select count(*), sum(e.salaryint32) from example.employee e

Tokens: 
[<SELECT>][<COUNT>][(][*][)][,][<SUM>][(][e][.][salaryint32][)][<FROM>][example][.]
[employee][e]

Parse tree: 
select1(
    all
    [
        as(
            setFunction(
                count
                all
                literal(integer,1)
            )
            name(noName)
        )
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint32)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(count,all,literal(integer,1)))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            count
            all
            literal(integer,1)
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(count,all,literal(integer,1)))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            count
            all
            literal(integer,1)
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,0)])
            name(noName)
        )
        as(
            path(integer,[extent(1,temp),property(integer,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            count
            all
            literal(integer,1)
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,0)])
            name(noName)
        )
        as(
            path(integer,[extent(1,temp),property(integer,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            count
            all
            literal(integer,1)
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer,integer])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,0)])
        )
        map(
            1
            path(integer,[extent(1,temp),property(integer,1)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer,integer])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,0)])
        )
        map(
            1
            path(integer,[extent(1,temp),property(integer,1)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.department.name, sum(e.salaryint16 * 2) * 3 from example.employee e group by e.department having sum(e.salaryint32) > 0 order by e.department

Tokens: 
[<SELECT>][e][.][department][.][name][,][<SUM>][(][e][.][salaryint16][*][2][)]
[*][3][<FROM>][example][.][employee][e][<GROUP>][<BY>][e][.][department][<HAVING>][<SUM>][(]
[e][.][salaryint32][)][>][0][<ORDER>][<BY>][e][.][department]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,department),property(any,name)])
            name(noName)
        )
        as(
            operation(
                numerical
                multiplication
                setFunction(
                    sum
                    all
                    operation(
                        numerical
                        multiplication
                        path(any,[property(any,e),property(any,salaryint16)])
                        literal(integer,2)
                    )
                )
                literal(integer,3)
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
        path(any,[property(any,e),property(any,department)])
    ]
    comparison(
        any
        greaterThan
        setFunction(
            sum
            all
            path(any,[property(any,e),property(any,salaryint32)])
        )
        literal(integer,0)
    )
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,department)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,operation(numerical,multiplication,path(any,[extent(0,example.employee),property(any,salaryint16)]),literal(integer,2))))
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            sum
            all
            operation(
                numerical
                multiplication
                path(any,[extent(0,example.employee),property(any,salaryint16)])
                literal(integer,2)
            )
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            any
            tmpPath([extent(1,temp),property(any,0)],path(any,[extent(0,example.employee),property(any,department)]))
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,operation(numerical,multiplication,path(any,[extent(0,example.employee),property(any,salaryint16)]),literal(integer,2))))
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            sum
            all
            operation(
                numerical
                multiplication
                path(any,[extent(0,example.employee),property(any,salaryint16)])
                literal(integer,2)
            )
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            any
            tmpPath([extent(1,temp),property(any,0)],path(any,[extent(0,example.employee),property(any,department)]))
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,1)])
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            operation(
                integer
                multiplication
                path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                literal(integer,2)
            )
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(1,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,1)])
                literal(integer,3)
            )
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            operation(
                integer
                multiplication
                path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                literal(integer,2)
            )
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(1,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,1)])
                literal(integer,3)
            )
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,1)])
                literal(integer,3)
            )
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select d.name, sum(e.salaryint16) from example.employee e join example.department d where e.department = d group by d having sum(e.salaryint32) > 0 order by d.name

Tokens: 
[<SELECT>][d][.][name][,][<SUM>][(][e][.][salaryint16][)][<FROM>][example][.][employee]
[e][<JOIN>][example][.][department][d][<WHERE>][e][.][department][=][d][<GROUP>][<BY>][d]
[<HAVING>][<SUM>][(][e][.][salaryint32][)][>][0][<ORDER>][<BY>][d][.][name]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint16)])
            )
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        as(
            extent(any,example.department)
            alias(any,d)
        )
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,department)])
        path(any,[property(any,d)])
    )
    [
        path(any,[property(any,d)])
    ]
    comparison(
        any
        greaterThan
        setFunction(
            sum
            all
            path(any,[property(any,e),property(any,salaryint32)])
        )
        literal(integer,0)
    )
    [
        sortSpec(
            any
            path(any,[property(any,d),property(any,name)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(2,temp),property(any,0),property(any,name)],path(any,[extent(1,example.department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(2,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint16)])))
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.employee)
        extent(1,example.department)
        literal(logical,true)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
        path(any,[extent(1,example.department)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint16)])
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(2,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(2,temp)
    [
        sortSpec(
            any
            tmpPath([extent(2,temp),property(any,0),property(any,name)],path(any,[extent(1,example.department),property(any,name)]))
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(2,temp),property(any,0),property(any,name)],path(any,[extent(1,example.department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(2,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint16)])))
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.employee)
        extent(1,example.department)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(1,example.department)])
    )
    [
        path(any,[extent(1,example.department)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint16)])
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(2,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(2,temp)
    [
        sortSpec(
            any
            tmpPath([extent(2,temp),property(any,0),property(any,name)],path(any,[extent(1,example.department),property(any,name)]))
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(integer,[extent(2,temp),property(integer,1)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(1,Example.Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(2,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(2,temp)
    [
        sortSpec(
            string
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(integer,[extent(2,temp),property(integer,1)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Employee)
        extent(1,Example.Department)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
        path(object(Example.Department),[extent(1,Example.Department)])
    )
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(1,Example.Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(2,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(2,temp)
    [
        sortSpec(
            string
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
        extent(2,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(integer,[extent(2,temp),property(integer,1)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Department)
        extent(2,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(2,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(integer,[extent(2,temp),property(integer,1)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select d.name, sum(e.salaryint32) from example.department d join example.employee e on d = e.department group by d.name

Tokens: 
[<SELECT>][d][.][name][,][<SUM>][(][e][.][salaryint32][)][<FROM>][example][.][department]
[d][<JOIN>][example][.][employee][e][<ON>][d][=][e][.][department][<GROUP>][<BY>][d]
[.][name]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,d),property(any,name)])
            name(noName)
        )
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint32)])
            )
            name(noName)
        )
    ]
    join1(
        inner
        as(
            extent(any,example.department)
            alias(any,d)
        )
        as(
            extent(any,example.employee)
            alias(any,e)
        )
        comparison(
            any
            equal
            path(any,[property(any,d)])
            path(any,[property(any,e),property(any,department)])
        )
    )
    literal(logical,true)
    [
        path(any,[property(any,d),property(any,name)])
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(2,temp),property(any,0)],path(any,[extent(0,example.department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(2,temp),property(any,1)],setFunction(sum,all,path(any,[extent(1,example.employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    join1(
        inner
        extent(0,example.department)
        extent(1,example.employee)
        comparison(
            any
            equal
            path(any,[extent(0,example.department)])
            path(any,[extent(1,example.employee),property(any,department)])
        )
    )
    literal(logical,true)
    [
        path(any,[extent(0,example.department),property(any,name)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(1,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(2,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(2,temp),property(any,0)],path(any,[extent(0,example.department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(2,temp),property(any,1)],setFunction(sum,all,path(any,[extent(1,example.employee),property(any,salaryint32)])))
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,example.department)
        extent(1,example.employee)
    )
    comparison(
        any
        equal
        path(any,[extent(0,example.department)])
        path(any,[extent(1,example.employee),property(any,department)])
    )
    [
        path(any,[extent(0,example.department),property(any,name)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(1,example.employee),property(any,salaryint32)])
        )
    ]
    literal(logical,true)
    extent(2,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(2,temp),property(string,0)])
            name(noName)
        )
        as(
            path(integer,[extent(2,temp),property(integer,1)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Department)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Department)])
        path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Department),property(string,Name)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(1,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(2,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(2,temp),property(string,0)])
            name(noName)
        )
        as(
            path(integer,[extent(2,temp),property(integer,1)])
            name(noName)
        )
    ]
    join2(
        inner
        extent(0,Example.Department)
        extent(1,Example.Employee)
    )
    comparison(
        object(Example.Department)
        equal
        path(object(Example.Department),[extent(0,Example.Department)])
        path(object(Example.Department),[extent(1,Example.Employee),property(object(Example.Department),Department)])
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Department),property(string,Name)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(1,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    literal(logical,true)
    extent(2,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
        extent(2,[string,integer])
    ]
    [
        map(
            0
            path(string,[extent(2,temp),property(string,0)])
        )
        map(
            1
            path(integer,[extent(2,temp),property(integer,1)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Department)
        extent(1,Example.Employee)
        extent(2,[string,integer])
    ]
    [
        map(
            0
            path(string,[extent(2,temp),property(string,0)])
        )
        map(
            1
            path(integer,[extent(2,temp),property(integer,1)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 16
Type: pos
Query: 
select e.department, e.department.name, sum(e.salarydouble), avg(e.salarydecimal), min(e.salaryuint64), max(e.salarysingle) from example.employee e group by e.department, e.commission

Tokens: 
[<SELECT>][e][.][department][,][e][.][department][.][name][,][<SUM>][(][e][.]
[salarydouble][)][,][<AVG>][(][e][.][salarydecimal][)][,][<MIN>][(][e][.][salaryuint64]
[)][,][<MAX>][(][e][.][salarysingle][)][<FROM>][example][.][employee][e][<GROUP>][<BY>]
[e][.][department][,][e][.][commission]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,department)])
            name(noName)
        )
        as(
            path(any,[property(any,e),property(any,department),property(any,name)])
            name(noName)
        )
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salarydouble)])
            )
            name(noName)
        )
        as(
            setFunction(
                avg
                all
                path(any,[property(any,e),property(any,salarydecimal)])
            )
            name(noName)
        )
        as(
            setFunction(
                min
                all
                path(any,[property(any,e),property(any,salaryuint64)])
            )
            name(noName)
        )
        as(
            setFunction(
                max
                all
                path(any,[property(any,e),property(any,salarysingle)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
        path(any,[property(any,e),property(any,department)])
        path(any,[property(any,e),property(any,commission)])
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],path(any,[extent(0,example.employee),property(any,department)]))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salarydouble)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,3)],setFunction(avg,all,path(any,[extent(0,example.employee),property(any,salarydecimal)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,4)],setFunction(min,all,path(any,[extent(0,example.employee),property(any,salaryuint64)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,5)],setFunction(max,all,path(any,[extent(0,example.employee),property(any,salarysingle)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(0,example.employee),property(any,commission)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salarydouble)])
        )
        setFunction(
            avg
            all
            path(any,[extent(0,example.employee),property(any,salarydecimal)])
        )
        setFunction(
            min
            all
            path(any,[extent(0,example.employee),property(any,salaryuint64)])
        )
        setFunction(
            max
            all
            path(any,[extent(0,example.employee),property(any,salarysingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],path(any,[extent(0,example.employee),property(any,department)]))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salarydouble)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,3)],setFunction(avg,all,path(any,[extent(0,example.employee),property(any,salarydecimal)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,4)],setFunction(min,all,path(any,[extent(0,example.employee),property(any,salaryuint64)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,5)],setFunction(max,all,path(any,[extent(0,example.employee),property(any,salarysingle)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
        path(any,[extent(0,example.employee),property(any,commission)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salarydouble)])
        )
        setFunction(
            avg
            all
            path(any,[extent(0,example.employee),property(any,salarydecimal)])
        )
        setFunction(
            min
            all
            path(any,[extent(0,example.employee),property(any,salaryuint64)])
        )
        setFunction(
            max
            all
            path(any,[extent(0,example.employee),property(any,salarysingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
            name(noName)
        )
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,2)])
            name(noName)
        )
        as(
            path(decimal,[extent(1,temp),property(decimal,3)])
            name(noName)
        )
        as(
            path(uinteger,[extent(1,temp),property(uinteger,4)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,5)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
        sortSpec(
            boolean
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            asc
        )
    ]
    [
        setFunction(
            double
            sum
            all
            path(double,[extent(0,Example.Employee),property(double,SalaryDouble)])
        )
        setFunction(
            decimal
            avg
            all
            path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
        )
        setFunction(
            uinteger
            min
            all
            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt64)])
        )
        setFunction(
            double
            max
            all
            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
            name(noName)
        )
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,2)])
            name(noName)
        )
        as(
            path(decimal,[extent(1,temp),property(decimal,3)])
            name(noName)
        )
        as(
            path(uinteger,[extent(1,temp),property(uinteger,4)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,5)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
        sortSpec(
            boolean
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            asc
        )
    ]
    [
        setFunction(
            double
            sum
            all
            path(double,[extent(0,Example.Employee),property(double,SalaryDouble)])
        )
        setFunction(
            decimal
            avg
            all
            path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
        )
        setFunction(
            uinteger
            min
            all
            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt64)])
        )
        setFunction(
            double
            max
            all
            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),boolean,double,decimal,uinteger,double])
    ]
    [
        map(
            0
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
        )
        map(
            1
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            2
            path(double,[extent(1,temp),property(double,2)])
        )
        map(
            3
            path(decimal,[extent(1,temp),property(decimal,3)])
        )
        map(
            4
            path(uinteger,[extent(1,temp),property(uinteger,4)])
        )
        map(
            5
            path(double,[extent(1,temp),property(double,5)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),boolean,double,decimal,uinteger,double])
    ]
    [
        map(
            0
            path(object(Example.Department),[extent(1,temp),property(object(Example.Department),0)])
        )
        map(
            1
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            2
            path(double,[extent(1,temp),property(double,2)])
        )
        map(
            3
            path(decimal,[extent(1,temp),property(decimal,3)])
        )
        map(
            4
            path(uinteger,[extent(1,temp),property(uinteger,4)])
        )
        map(
            5
            path(double,[extent(1,temp),property(double,5)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select sum(e.salaryint64), avg(e.salarysingle) from example.employee e group by e.commission, e.hiredate, e.manager, e.salaryint32, e.salaryuint32, e.salarydouble, e.salarydecimal

Tokens: 
[<SELECT>][<SUM>][(][e][.][salaryint64][)][,][<AVG>][(][e][.][salarysingle][)][<FROM>]
[example][.][employee][e][<GROUP>][<BY>][e][.][commission][,][e][.][hiredate][,][e]
[.][manager][,][e][.][salaryint32][,][e][.][salaryuint32][,][e][.][salarydouble][,]
[e][.][salarydecimal]

Parse tree: 
select1(
    all
    [
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint64)])
            )
            name(noName)
        )
        as(
            setFunction(
                avg
                all
                path(any,[property(any,e),property(any,salarysingle)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
        path(any,[property(any,e),property(any,commission)])
        path(any,[property(any,e),property(any,hiredate)])
        path(any,[property(any,e),property(any,manager)])
        path(any,[property(any,e),property(any,salaryint32)])
        path(any,[property(any,e),property(any,salaryuint32)])
        path(any,[property(any,e),property(any,salarydouble)])
        path(any,[property(any,e),property(any,salarydecimal)])
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,7)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint64)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,8)],setFunction(avg,all,path(any,[extent(0,example.employee),property(any,salarysingle)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,commission)])
        path(any,[extent(0,example.employee),property(any,hiredate)])
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee),property(any,salaryint32)])
        path(any,[extent(0,example.employee),property(any,salaryuint32)])
        path(any,[extent(0,example.employee),property(any,salarydouble)])
        path(any,[extent(0,example.employee),property(any,salarydecimal)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint64)])
        )
        setFunction(
            avg
            all
            path(any,[extent(0,example.employee),property(any,salarysingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,7)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint64)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,8)],setFunction(avg,all,path(any,[extent(0,example.employee),property(any,salarysingle)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,commission)])
        path(any,[extent(0,example.employee),property(any,hiredate)])
        path(any,[extent(0,example.employee),property(any,manager)])
        path(any,[extent(0,example.employee),property(any,salaryint32)])
        path(any,[extent(0,example.employee),property(any,salaryuint32)])
        path(any,[extent(0,example.employee),property(any,salarydouble)])
        path(any,[extent(0,example.employee),property(any,salarydecimal)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint64)])
        )
        setFunction(
            avg
            all
            path(any,[extent(0,example.employee),property(any,salarysingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,7)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,8)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            boolean
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            asc
        )
        sortSpec(
            datetime
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
            asc
        )
        sortSpec(
            object(Example.Employee)
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            asc
        )
        sortSpec(
            integer
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
            asc
        )
        sortSpec(
            uinteger
            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt32)])
            asc
        )
        sortSpec(
            double
            path(double,[extent(0,Example.Employee),property(double,SalaryDouble)])
            asc
        )
        sortSpec(
            decimal
            path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
        )
        setFunction(
            double
            avg
            all
            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(integer,[extent(1,temp),property(integer,7)])
            name(noName)
        )
        as(
            path(double,[extent(1,temp),property(double,8)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            boolean
            path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
            asc
        )
        sortSpec(
            datetime
            path(datetime,[extent(0,Example.Employee),property(datetime,HireDate)])
            asc
        )
        sortSpec(
            object(Example.Employee)
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
            asc
        )
        sortSpec(
            integer
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
            asc
        )
        sortSpec(
            uinteger
            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt32)])
            asc
        )
        sortSpec(
            double
            path(double,[extent(0,Example.Employee),property(double,SalaryDouble)])
            asc
        )
        sortSpec(
            decimal
            path(decimal,[extent(0,Example.Employee),property(decimal,SalaryDecimal)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
        )
        setFunction(
            double
            avg
            all
            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[boolean,datetime,object(Example.Employee),integer,uinteger,double,decimal,integer,double])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,7)])
        )
        map(
            1
            path(double,[extent(1,temp),property(double,8)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[boolean,datetime,object(Example.Employee),integer,uinteger,double,decimal,integer,double])
    ]
    [
        map(
            0
            path(integer,[extent(1,temp),property(integer,7)])
        )
        map(
            1
            path(double,[extent(1,temp),property(double,8)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select max(null) from example.employee

Tokens: 
[<SELECT>][<MAX>][(][<NULL>][)][<FROM>][example][.][employee]

Parse tree: 
select1(
    all
    [
        as(
            setFunction(
                max
                all
                literal(any,null)
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,noName)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(max,all,literal(any,null)))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            max
            all
            literal(any,null)
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0)],setFunction(max,all,literal(any,null)))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            max
            all
            literal(any,null)
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(string,0)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            string
            max
            all
            literal(string,null)
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(string,0)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            string
            max
            all
            literal(string,null)
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[string])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(string,0)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[string])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(string,0)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: neg
Query: 
select f.loc.name, f.sum1 + h.sum2 from (select e.department.location loc, sum(all e.salaryint32) sum1 from example.employee e where e.firstname <> 'peter' group by e.department.location) f join (select sum(g.salaryint32) sum2 from example.employee g group by g.department having sum(g.salaryint32) > 1) h

Tokens: 
[<SELECT>][f][.][loc][.][name][,][f][.][sum1][+][h][.][sum2][<FROM>]
[(][<SELECT>][e][.][department][.][location][loc][,][<SUM>][(][<ALL>][e][.][salaryint32]
[)][sum1][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][<>]['peter'][<GROUP>][<BY>]
[e][.][department][.][location][)][f][<JOIN>][(][<SELECT>][<SUM>][(][g][.][salaryint32]
[)][sum2][<FROM>][example][.][employee][g][<GROUP>][<BY>][g][.][department][<HAVING>][<SUM>][(]
[g][.][salaryint32][)][>][1][)][h]

Parse tree: 
noTree

Rewritten tree 1: 
noTree

Rewritten tree 2: 
noTree

Controlled tree: 
noTree

Modified tree: 
noTree

Type definition: 
noTypeDef

Modified type definition: 
noTypeDef

Number of variables: 
0

Errors: 
[
    Incorrect syntax.
]


Runtime: 15
Type: neg
Query: 
select sum(e.salaryint64) * 3, max(e.manager), min(e) from example.employee e

Tokens: 
[<SELECT>][<SUM>][(][e][.][salaryint64][)][*][3][,][<MAX>][(][e][.][manager]
[)][,][<MIN>][(][e][)][<FROM>][example][.][employee][e]

Parse tree: 
select1(
    all
    [
        as(
            operation(
                numerical
                multiplication
                setFunction(
                    sum
                    all
                    path(any,[property(any,e),property(any,salaryint64)])
                )
                literal(integer,3)
            )
            name(noName)
        )
        as(
            setFunction(
                max
                all
                path(any,[property(any,e),property(any,manager)])
            )
            name(noName)
        )
        as(
            setFunction(
                min
                all
                path(any,[property(any,e)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint64)])))
                literal(integer,3)
            )
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(max,all,path(any,[extent(0,example.employee),property(any,manager)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,2)],setFunction(min,all,path(any,[extent(0,example.employee)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint64)])
        )
        setFunction(
            max
            all
            path(any,[extent(0,example.employee),property(any,manager)])
        )
        setFunction(
            min
            all
            path(any,[extent(0,example.employee)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            operation(
                numerical
                multiplication
                tmpPath([extent(1,temp),property(any,0)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint64)])))
                literal(integer,3)
            )
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(max,all,path(any,[extent(0,example.employee),property(any,manager)])))
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,2)],setFunction(min,all,path(any,[extent(0,example.employee)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint64)])
        )
        setFunction(
            max
            all
            path(any,[extent(0,example.employee),property(any,manager)])
        )
        setFunction(
            min
            all
            path(any,[extent(0,example.employee)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                literal(integer,3)
            )
            name(noName)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,1)])
            name(noName)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,2)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
        )
        setFunction(
            unknown
            max
            all
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        )
        setFunction(
            unknown
            min
            all
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                literal(integer,3)
            )
            name(noName)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,1)])
            name(noName)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,2)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
        )
        setFunction(
            unknown
            max
            all
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        )
        setFunction(
            unknown
            min
            all
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer,unknown,unknown])
    ]
    [
        map(
            0
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                literal(integer,3)
            )
        )
        map(
            1
            path(unknown,[extent(1,temp),property(unknown,1)])
        )
        map(
            2
            path(unknown,[extent(1,temp),property(unknown,2)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[integer,unknown,unknown])
    ]
    [
        map(
            0
            operation(
                integer
                multiplication
                path(integer,[extent(1,temp),property(integer,0)])
                literal(integer,3)
            )
        )
        map(
            1
            path(unknown,[extent(1,temp),property(unknown,1)])
        )
        map(
            2
            path(unknown,[extent(1,temp),property(unknown,2)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Incorrect argument of type object(Example.Employee) to set-function max.
    Incorrect argument of type object(Example.Employee) to set-function min.
]


Runtime: 0
Type: neg
Query: 
select e.department.name dname, min(e.manager) from example.employee e group by e.department

Tokens: 
[<SELECT>][e][.][department][.][name][dname][,][<MIN>][(][e][.][manager][)][<FROM>]
[example][.][employee][e][<GROUP>][<BY>][e][.][department]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,department),property(any,name)])
            name(dname)
        )
        as(
            setFunction(
                min
                all
                path(any,[property(any,e),property(any,manager)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
        path(any,[property(any,e),property(any,department)])
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(dname)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(min,all,path(any,[extent(0,example.employee),property(any,manager)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            min
            all
            path(any,[extent(0,example.employee),property(any,manager)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(dname)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(min,all,path(any,[extent(0,example.employee),property(any,manager)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            min
            all
            path(any,[extent(0,example.employee),property(any,manager)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(dname)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            unknown
            min
            all
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(dname)
        )
        as(
            path(unknown,[extent(1,temp),property(unknown,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            unknown
            min
            all
            path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
        )
    ]
    literal(logical,true)
    extent(1,temp)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),unknown])
    ]
    [
        map(
            dname
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(unknown,[extent(1,temp),property(unknown,1)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),unknown])
    ]
    [
        map(
            dname
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(unknown,[extent(1,temp),property(unknown,1)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Incorrect argument of type object(Example.Employee) to set-function min.
]


Runtime: 0
Type: neg
Query: 
select e.department.name, e.firstname, sum(e.salaryint16) from example.employee e group by e.department having sum(e.salaryint32) > 0 order by e.lastname

Tokens: 
[<SELECT>][e][.][department][.][name][,][e][.][firstname][,][<SUM>][(][e][.]
[salaryint16][)][<FROM>][example][.][employee][e][<GROUP>][<BY>][e][.][department][<HAVING>][<SUM>][(]
[e][.][salaryint32][)][>][0][<ORDER>][<BY>][e][.][lastname]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,department),property(any,name)])
            name(noName)
        )
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
        as(
            setFunction(
                sum
                all
                path(any,[property(any,e),property(any,salaryint16)])
            )
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    literal(logical,true)
    [
        path(any,[property(any,e),property(any,department)])
    ]
    comparison(
        any
        greaterThan
        setFunction(
            sum
            all
            path(any,[property(any,e),property(any,salaryint32)])
        )
        literal(integer,0)
    )
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint16)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint16)])
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select3(
    all
    [
        as(
            tmpPath([extent(1,temp),property(any,0),property(any,name)],path(any,[extent(0,example.employee),property(any,department),property(any,name)]))
            name(noName)
        )
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            tmpPath([extent(1,temp),property(any,1)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint16)])))
            name(noName)
        )
    ]
    extent(0,example.employee)
    literal(logical,true)
    [
        path(any,[extent(0,example.employee),property(any,department)])
    ]
    [
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint16)])
        )
        setFunction(
            sum
            all
            path(any,[extent(0,example.employee),property(any,salaryint32)])
        )
    ]
    comparison(
        any
        greaterThan
        tmpPath([extent(1,temp),property(any,2)],setFunction(sum,all,path(any,[extent(0,example.employee),property(any,salaryint32)])))
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,lastname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(integer,[extent(1,temp),property(integer,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(1,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select3(
    all
    [
        as(
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
            name(noName)
        )
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(integer,[extent(1,temp),property(integer,1)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    literal(logical,true)
    [
        sortSpec(
            object(Example.Department)
            path(object(Example.Department),[extent(0,Example.Employee),property(object(Example.Department),Department)])
            asc
        )
    ]
    [
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
        )
        setFunction(
            integer
            sum
            all
            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt32)])
        )
    ]
    comparison(
        integer
        greaterThan
        path(integer,[extent(1,temp),property(integer,2)])
        literal(integer,0)
    )
    extent(1,temp)
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(integer,[extent(1,temp),property(integer,1)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,[object(Example.Department),integer,integer])
    ]
    [
        map(
            0
            path(string,[extent(1,temp),property(object(Example.Department),0),property(string,Name)])
        )
        map(
            1
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(integer,[extent(1,temp),property(integer,1)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
    Incorrect select-list w.r.t. group-by-clause.
    Incorrect order-by-clause w.r.t. group-by-clause.
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.commission = true

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][commission][=][<TRUE>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),property(any,commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        boolean
        equal
        path(boolean,[extent(0,Example.Employee),property(boolean,Commission)])
        literal(boolean,true)
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.department.name from example.employee e where e.lastname = 'idestam' and e.firstname > 'bertil' order by e.firstname

Tokens: 
[<SELECT>][e][.][department][.][name][<FROM>][example][.][employee][e][<WHERE>][e][.][lastname]
[=]['idestam'][<AND>][e][.][firstname][>]['bertil'][<ORDER>][<BY>][e][.][firstname]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            greaterThan
            path(any,[property(any,e),property(any,firstname)])
            literal(string,'bertil')
        )
    )
    [
    ]
    literal(logical,true)
    [
        sortSpec(
            any
            path(any,[property(any,e),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            greaterThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'bertil')
        )
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,department),property(any,name)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            greaterThan
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'bertil')
        )
    )
    [
        sortSpec(
            any
            path(any,[extent(0,example.employee),property(any,firstname)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'idestam')
        )
        comparison(
            string
            greaterThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'bertil')
        )
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'idestam')
        )
        comparison(
            string
            greaterThan
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,'bertil')
        )
    )
    [
        sortSpec(
            string
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            asc
        )
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(object(Example.Department),Department),property(string,Name)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.lastname from example.employee e where e.lastname = 'idestam' and e.lastname <= 'samuelsson'

Tokens: 
[<SELECT>][e][.][lastname][<FROM>][example][.][employee][e][<WHERE>][e][.][lastname][=]['idestam']
[<AND>][e][.][lastname][<=]['samuelsson']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,lastname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            lessThanOrEqual
            path(any,[property(any,e),property(any,lastname)])
            literal(string,'samuelsson')
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'samuelsson')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,lastname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'idestam')
        )
        comparison(
            any
            lessThanOrEqual
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(string,'samuelsson')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'idestam')
        )
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'samuelsson')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            equal
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'idestam')
        )
        comparison(
            string
            lessThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,'samuelsson')
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e1.firstname, e2.firstname, e3.firstname, e4.firstname from example.employee e1 join example.employee e2 on e1.firstname = e2.firstname join example.employee e3 on e2.firstname = e3.firstname join example.employee e4 on e3.firstname = e4.firstname where e1.firstname = 'peter' and e2.firstname = 'per' and e3.firstname = 'erik' and e4.firstname = 'christian'

Tokens: 
[<SELECT>][e1][.][firstname][,][e2][.][firstname][,][e3][.][firstname][,][e4][.]
[firstname][<FROM>][example][.][employee][e1][<JOIN>][example][.][employee][e2][<ON>][e1][.][firstname]
[=][e2][.][firstname][<JOIN>][example][.][employee][e3][<ON>][e2][.][firstname][=][e3]
[.][firstname][<JOIN>][example][.][employee][e4][<ON>][e3][.][firstname][=][e4][.][firstname]
[<WHERE>][e1][.][firstname][=]['peter'][<AND>][e2][.][firstname][=]['per'][<AND>][e3][.]
[firstname][=]['erik'][<AND>][e4][.][firstname][=]['christian']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e1),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e2),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e3),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[property(any,e4),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            join1(
                inner
                as(
                    extent(any,example.employee)
                    alias(any,e1)
                )
                as(
                    extent(any,example.employee)
                    alias(any,e2)
                )
                comparison(
                    any
                    equal
                    path(any,[property(any,e1),property(any,firstname)])
                    path(any,[property(any,e2),property(any,firstname)])
                )
            )
            as(
                extent(any,example.employee)
                alias(any,e3)
            )
            comparison(
                any
                equal
                path(any,[property(any,e2),property(any,firstname)])
                path(any,[property(any,e3),property(any,firstname)])
            )
        )
        as(
            extent(any,example.employee)
            alias(any,e4)
        )
        comparison(
            any
            equal
            path(any,[property(any,e3),property(any,firstname)])
            path(any,[property(any,e4),property(any,firstname)])
        )
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[property(any,e1),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e2),property(any,firstname)])
                literal(string,'per')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[property(any,e3),property(any,firstname)])
                    literal(string,'erik')
                )
                comparison(
                    any
                    equal
                    path(any,[property(any,e4),property(any,firstname)])
                    literal(string,'christian')
                )
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join1(
        inner
        join1(
            inner
            join1(
                inner
                extent(0,example.employee)
                extent(1,example.employee)
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,firstname)])
                    path(any,[extent(1,example.employee),property(any,firstname)])
                )
            )
            extent(2,example.employee)
            comparison(
                any
                equal
                path(any,[extent(1,example.employee),property(any,firstname)])
                path(any,[extent(2,example.employee),property(any,firstname)])
            )
        )
        extent(3,example.employee)
        comparison(
            any
            equal
            path(any,[extent(2,example.employee),property(any,firstname)])
            path(any,[extent(3,example.employee),property(any,firstname)])
        )
    )
    operation(
        logical
        and
        comparison(
            any
            equal
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(string,'peter')
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(1,example.employee),property(any,firstname)])
                literal(string,'per')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(2,example.employee),property(any,firstname)])
                    literal(string,'erik')
                )
                comparison(
                    any
                    equal
                    path(any,[extent(3,example.employee),property(any,firstname)])
                    literal(string,'christian')
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(1,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(2,example.employee),property(any,firstname)])
            name(noName)
        )
        as(
            path(any,[extent(3,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,example.employee)
                extent(1,example.employee)
            )
            extent(2,example.employee)
        )
        extent(3,example.employee)
    )
    operation(
        logical
        and
        operation(
            logical
            and
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(0,example.employee),property(any,firstname)])
                    path(any,[extent(1,example.employee),property(any,firstname)])
                )
                comparison(
                    any
                    equal
                    path(any,[extent(1,example.employee),property(any,firstname)])
                    path(any,[extent(2,example.employee),property(any,firstname)])
                )
            )
            comparison(
                any
                equal
                path(any,[extent(2,example.employee),property(any,firstname)])
                path(any,[extent(3,example.employee),property(any,firstname)])
            )
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,firstname)])
                literal(string,'peter')
            )
            operation(
                logical
                and
                comparison(
                    any
                    equal
                    path(any,[extent(1,example.employee),property(any,firstname)])
                    literal(string,'per')
                )
                operation(
                    logical
                    and
                    comparison(
                        any
                        equal
                        path(any,[extent(2,example.employee),property(any,firstname)])
                        literal(string,'erik')
                    )
                    comparison(
                        any
                        equal
                        path(any,[extent(3,example.employee),property(any,firstname)])
                        literal(string,'christian')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Employee)
                extent(1,Example.Employee)
            )
            extent(2,Example.Employee)
        )
        extent(3,Example.Employee)
    )
    operation(
        logical
        and
        operation(
            logical
            and
            operation(
                logical
                and
                comparison(
                    string
                    equal
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                )
                comparison(
                    string
                    equal
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                    path(string,[extent(2,Example.Employee),property(string,FirstName)])
                )
            )
            comparison(
                string
                equal
                path(string,[extent(2,Example.Employee),property(string,FirstName)])
                path(string,[extent(3,Example.Employee),property(string,FirstName)])
            )
        )
        operation(
            logical
            and
            comparison(
                string
                equal
                path(string,[extent(0,Example.Employee),property(string,FirstName)])
                literal(string,'peter')
            )
            operation(
                logical
                and
                comparison(
                    string
                    equal
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                    literal(string,'per')
                )
                operation(
                    logical
                    and
                    comparison(
                        string
                        equal
                        path(string,[extent(2,Example.Employee),property(string,FirstName)])
                        literal(string,'erik')
                    )
                    comparison(
                        string
                        equal
                        path(string,[extent(3,Example.Employee),property(string,FirstName)])
                        literal(string,'christian')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
            name(noName)
        )
        as(
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    join2(
        inner
        join2(
            inner
            join2(
                inner
                extent(0,Example.Employee)
                extent(1,Example.Employee)
            )
            extent(2,Example.Employee)
        )
        extent(3,Example.Employee)
    )
    operation(
        logical
        and
        operation(
            logical
            and
            operation(
                logical
                and
                comparison(
                    string
                    equal
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                )
                comparison(
                    string
                    equal
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                    path(string,[extent(2,Example.Employee),property(string,FirstName)])
                )
            )
            comparison(
                string
                equal
                path(string,[extent(2,Example.Employee),property(string,FirstName)])
                path(string,[extent(3,Example.Employee),property(string,FirstName)])
            )
        )
        operation(
            logical
            and
            comparison(
                string
                equal
                path(string,[extent(0,Example.Employee),property(string,FirstName)])
                literal(string,'peter')
            )
            operation(
                logical
                and
                comparison(
                    string
                    equal
                    path(string,[extent(1,Example.Employee),property(string,FirstName)])
                    literal(string,'per')
                )
                operation(
                    logical
                    and
                    comparison(
                        string
                        equal
                        path(string,[extent(2,Example.Employee),property(string,FirstName)])
                        literal(string,'erik')
                    )
                    comparison(
                        string
                        equal
                        path(string,[extent(3,Example.Employee),property(string,FirstName)])
                        literal(string,'christian')
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
        )
        map(
            3
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
        extent(1,Example.Employee)
        extent(2,Example.Employee)
        extent(3,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
        map(
            1
            path(string,[extent(1,Example.Employee),property(string,FirstName)])
        )
        map(
            2
            path(string,[extent(2,Example.Employee),property(string,FirstName)])
        )
        map(
            3
            path(string,[extent(3,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.firstname >= e.lastname and e.manager = e and e.firstname > 'erik' and (e.salaryint16 = e.salaryint64 or e.salaryint16 = e.salaryuint64 or e.salaryint16 = e.salarysingle)

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][firstname][>=][e]
[.][lastname][<AND>][e][.][manager][=][e][<AND>][e][.][firstname][>]['erik'][<AND>]
[(][e][.][salaryint16][=][e][.][salaryint64][<OR>][e][.][salaryint16][=][e][.]
[salaryuint64][<OR>][e][.][salaryint16][=][e][.][salarysingle][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[property(any,e),property(any,firstname)])
            path(any,[property(any,e),property(any,lastname)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[property(any,e),property(any,manager)])
                path(any,[property(any,e)])
            )
            operation(
                logical
                and
                comparison(
                    any
                    greaterThan
                    path(any,[property(any,e),property(any,firstname)])
                    literal(string,'erik')
                )
                operation(
                    logical
                    or
                    comparison(
                        any
                        equal
                        path(any,[property(any,e),property(any,salaryint16)])
                        path(any,[property(any,e),property(any,salaryint64)])
                    )
                    operation(
                        logical
                        or
                        comparison(
                            any
                            equal
                            path(any,[property(any,e),property(any,salaryint16)])
                            path(any,[property(any,e),property(any,salaryuint64)])
                        )
                        comparison(
                            any
                            equal
                            path(any,[property(any,e),property(any,salaryint16)])
                            path(any,[property(any,e),property(any,salarysingle)])
                        )
                    )
                )
            )
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            path(any,[extent(0,example.employee),property(any,lastname)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,manager)])
                path(any,[extent(0,example.employee)])
            )
            operation(
                logical
                and
                comparison(
                    any
                    greaterThan
                    path(any,[extent(0,example.employee),property(any,firstname)])
                    literal(string,'erik')
                )
                operation(
                    logical
                    or
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        path(any,[extent(0,example.employee),property(any,salaryint64)])
                    )
                    operation(
                        logical
                        or
                        comparison(
                            any
                            equal
                            path(any,[extent(0,example.employee),property(any,salaryint16)])
                            path(any,[extent(0,example.employee),property(any,salaryuint64)])
                        )
                        comparison(
                            any
                            equal
                            path(any,[extent(0,example.employee),property(any,salaryint16)])
                            path(any,[extent(0,example.employee),property(any,salarysingle)])
                        )
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            greaterThanOrEqual
            path(any,[extent(0,example.employee),property(any,firstname)])
            path(any,[extent(0,example.employee),property(any,lastname)])
        )
        operation(
            logical
            and
            comparison(
                any
                equal
                path(any,[extent(0,example.employee),property(any,manager)])
                path(any,[extent(0,example.employee)])
            )
            operation(
                logical
                and
                comparison(
                    any
                    greaterThan
                    path(any,[extent(0,example.employee),property(any,firstname)])
                    literal(string,'erik')
                )
                operation(
                    logical
                    or
                    comparison(
                        any
                        equal
                        path(any,[extent(0,example.employee),property(any,salaryint16)])
                        path(any,[extent(0,example.employee),property(any,salaryint64)])
                    )
                    operation(
                        logical
                        or
                        comparison(
                            any
                            equal
                            path(any,[extent(0,example.employee),property(any,salaryint16)])
                            path(any,[extent(0,example.employee),property(any,salaryuint64)])
                        )
                        comparison(
                            any
                            equal
                            path(any,[extent(0,example.employee),property(any,salaryint16)])
                            path(any,[extent(0,example.employee),property(any,salarysingle)])
                        )
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                path(object(Example.Employee),[extent(0,Example.Employee)])
            )
            operation(
                logical
                and
                comparison(
                    string
                    greaterThan
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                    literal(string,'erik')
                )
                operation(
                    logical
                    or
                    comparison(
                        integer
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                    )
                    operation(
                        logical
                        or
                        comparison(
                            integer
                            equal
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt64)])
                        )
                        comparison(
                            double
                            equal
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                        )
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            greaterThanOrEqual
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            path(string,[extent(0,Example.Employee),property(string,LastName)])
        )
        operation(
            logical
            and
            comparison(
                object(Example.Employee)
                equal
                path(object(Example.Employee),[extent(0,Example.Employee),property(object(Example.Employee),Manager)])
                path(object(Example.Employee),[extent(0,Example.Employee)])
            )
            operation(
                logical
                and
                comparison(
                    string
                    greaterThan
                    path(string,[extent(0,Example.Employee),property(string,FirstName)])
                    literal(string,'erik')
                )
                operation(
                    logical
                    or
                    comparison(
                        integer
                        equal
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                        path(integer,[extent(0,Example.Employee),property(integer,SalaryInt64)])
                    )
                    operation(
                        logical
                        or
                        comparison(
                            integer
                            equal
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                            path(uinteger,[extent(0,Example.Employee),property(uinteger,SalaryUInt64)])
                        )
                        comparison(
                            double
                            equal
                            path(integer,[extent(0,Example.Employee),property(integer,SalaryInt16)])
                            path(double,[extent(0,Example.Employee),property(double,SalarySingle)])
                        )
                    )
                )
            )
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e.firstname from example.employee e where e.lastname is not null and e.firstname is not null

Tokens: 
[<SELECT>][e][.][firstname][<FROM>][example][.][employee][e][<WHERE>][e][.][lastname][<IS>][<NOT>]
[<NULL>][<AND>][e][.][firstname][<IS>][<NOT>][<NULL>]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e),property(any,firstname)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    operation(
        logical
        and
        comparison(
            any
            isNot
            path(any,[property(any,e),property(any,lastname)])
            literal(any,null)
        )
        comparison(
            any
            isNot
            path(any,[property(any,e),property(any,firstname)])
            literal(any,null)
        )
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            isNot
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(any,null)
        )
        comparison(
            any
            isNot
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(any,null)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee),property(any,firstname)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    operation(
        logical
        and
        comparison(
            any
            isNot
            path(any,[extent(0,example.employee),property(any,lastname)])
            literal(any,null)
        )
        comparison(
            any
            isNot
            path(any,[extent(0,example.employee),property(any,firstname)])
            literal(any,null)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            isNot
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,null)
        )
        comparison(
            string
            isNot
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,null)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    operation(
        logical
        and
        comparison(
            string
            isNot
            path(string,[extent(0,Example.Employee),property(string,LastName)])
            literal(string,null)
        )
        comparison(
            string
            isNot
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
            literal(string,null)
        )
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(string,[extent(0,Example.Employee),property(string,FirstName)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.getextension<example.myperson>().myname = 'peter2'

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][getextension][<][example][.][myperson]
[>][(][)][.][myname][=]['peter2']

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(string,MyName)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(string,MyName)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]


Runtime: 0
Type: pos
Query: 
select e from example.employee e where e.getextension<example.myperson>().myname = 'peter2' option index(e myindex)

Tokens: 
[<SELECT>][e][<FROM>][example][.][employee][e][<WHERE>][e][.][getextension][<][example][.][myperson]
[>][(][)][.][myname][=]['peter2'][<OPTION>][<INDEX>][(][e][myindex][)]

Parse tree: 
select1(
    all
    [
        as(
            path(any,[property(any,e)])
            name(noName)
        )
    ]
    as(
        extent(any,example.employee)
        alias(any,e)
    )
    comparison(
        any
        equal
        path(any,[property(any,e),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    literal(logical,true)
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(alias(any,e),indexName(myindex))
    ]
)

Rewritten tree 1: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Rewritten tree 2: 
select2(
    all
    [
        as(
            path(any,[extent(0,example.employee)])
            name(noName)
        )
    ]
    extent(0,example.employee)
    comparison(
        any
        equal
        path(any,[extent(0,example.employee),gmethod(any,getextension,[example.myperson],[]),property(any,myname)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,example.employee),indexName(myindex))
    ]
)

Controlled tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(string,MyName)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Modified tree: 
select2(
    all
    [
        as(
            path(object(Example.Employee),[extent(0,Example.Employee)])
            name(noName)
        )
    ]
    extent(0,Example.Employee)
    comparison(
        string
        equal
        path(string,[extent(0,Example.Employee),gmethod(object(Example.MyPerson),GetExtension,[Example.MyPerson],[]),property(string,MyName)])
        literal(string,'peter2')
    )
    [
    ]
    fetch(noNumber,noOffset)
    [
        indexHint(extent(0,Example.Employee),indexName(myindex))
    ]
)

Type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Modified type definition: 
typeDef(
    [
        extent(0,Example.Employee)
    ]
    [
        map(
            0
            path(object(Example.Employee),[extent(0,Example.Employee)])
        )
    ]
)

Number of variables: 
0

Errors: 
[
]

